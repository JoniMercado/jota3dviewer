function buildDoorControlsFromClips(gltf, scopeRoot){
  removeDoorUI();
  const clips = gltf.animations || [];
  if(!clips.length) return;

  const panel = document.getElementById('animPanel');
  if(!panel) return;

  // Agrupar por nodo destino (a partir del primer track)
  const byNode = new Map();
  clips.forEach(clip=>{
    if(!(clip && clip.tracks && clip.tracks.length)) return;
    const t0 = clip.tracks[0];                // p.ej. 'door_A.quaternion'
    const m = t0.name.match(/^([^.]*)\./);
    const nodeName = m ? m[1] : null;
    if(!nodeName || !/^door_/i.test(nodeName)) return;
    const node = scopeRoot.getObjectByName(nodeName);
    if(!node) return;
    if(!byNode.has(node)) byNode.set(node, []);
    byNode.get(node).push(clip);
  });

  // OJO: Map.forEach(value, key)
  byNode.forEach((clipsArr, node)=>{
    if(!Array.isArray(clipsArr) || clipsArr.length===0) return;

    // elegimos el clip más largo si hay varios
    const clip = clipsArr.reduce((a,b)=> (a.duration>=b.duration ? a : b));

    const mixer  = new THREE.AnimationMixer(node);
    const action = mixer.clipAction(clip);
    action.clampWhenFinished = true;
    action.loop = THREE.LoopOnce;
    action.play();
    action.paused = true;  // avanzamos manualmente con el slider
    action.time   = 0;

    const ctrl = { name: node.name, node, mixer, clip, action, sliderEl:null, tween:null };
    doorAnimControls.push(ctrl);
  });

  // UI: una fila (nombre + slider) por puerta animada
  doorAnimControls.forEach(ctrl=>{
    const row = document.createElement('div');
    row.className = 'anim-row';

    const nameEl = document.createElement('div');
    nameEl.className = 'anim-name';
    nameEl.textContent = stripDoorPrefixAndSuffix(ctrl.name);

    const slider = document.createElement('input');
    slider.type='range'; slider.min='0'; slider.max='1'; slider.step='0.01';
    slider.value='0'; slider.className='anim-slider';
    slider.oninput = ()=>{
      const v = parseFloat(slider.value);
      ctrl.action.time = v * ctrl.clip.duration;
      ctrl.action.paused = true;
      ctrl.mixer.update(0); // eval inmediata
    };

    row.appendChild(nameEl);
    row.appendChild(slider);
    panel.appendChild(row);
    ctrl.sliderEl = slider;
  });

  // Para pick por click: mapear subárboles de cada puerta
  objectToDoorIdx.clear();
  doorAnimControls.forEach((ctrl, idx)=>{
    ctrl.node.traverse(n=> objectToDoorIdx.set(n, idx));
  });
}
