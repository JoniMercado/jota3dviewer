<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>three.js GLB Viewer — Smart + Tools</title>
<style>
  html,body{height:100%;margin:0}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;background:#0b0d10;color:#e6e6e6}
  #topbar{position:fixed;inset:12px 12px auto 12px;display:flex;gap:8px;align-items:center;background:rgba(20,22,26,.8);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px 12px;z-index:10}
  #topbar input{width:440px;max-width:60vw;background:#0f1216;border:1px solid #2a2f36;color:#ddd;border-radius:10px;padding:8px 10px}
  #topbar button{background:#1e68ff;border:none;color:white;padding:8px 12px;border-radius:10px;cursor:pointer}
  #topbar small{opacity:.8}
  #fileInput{display:none}
  #stats{position:fixed;inset:auto 12px 12px 12px;background:rgba(20,22,26,.8);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:8px 12px;display:flex;gap:16px;flex-wrap:wrap}
  canvas{display:block;width:100%;height:100%}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.164/examples/jsm/"
  }
}
</script>
</head>
<body>
  <div id="topbar">
    <small>GLB URL</small>
    <input id="url" placeholder="https://example.com/model.glb" />
    <button id="loadBtn">Load</button>
    <button id="fileBtn">Open .glb</button>
    <input type="file" id="fileInput" accept=".glb,model/gltf-binary,model/gltf+binary,application/octet-stream" />
    <small id="msg"></small>
  </div>
  <div id="stats"></div>
  <canvas id="c"></canvas>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }     from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader }    from 'three/addons/loaders/DRACOLoader.js';
import { KTX2Loader }     from 'three/addons/loaders/KTX2Loader.js';
import { RGBELoader }     from 'three/addons/loaders/RGBELoader.js';
import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
import { RoomEnvironment }from 'three/addons/environments/RoomEnvironment.js';
import GUI from 'https://unpkg.com/lil-gui@0.19/dist/lil-gui.esm.js';

/* --- renderer / scene / camera --- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(2, 1.2, 2);

const pmrem = new THREE.PMREMGenerator(renderer);
let currentEnv = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
scene.environment = currentEnv;
renderer.setClearColor(new THREE.Color('#0b0d10'));

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0.6, 0);
controls.enableDamping = true;

/* --- loaders --- */
const draco = new DRACOLoader().setDecoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/draco/');
const ktx2  = new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/basis/').detectSupport(renderer);
const loader = new GLTFLoader().setDRACOLoader(draco).setKTX2Loader(ktx2);

/* --- iluminación integral (no direccional) --- */
const hemi = new THREE.HemisphereLight(0xffffff, 0x404040, 0.9);
scene.add(hemi);
const amb  = new THREE.AmbientLight(0xffffff, 0.25);
scene.add(amb);

/* --- helpers --- */
let current, lastGLTF=null;
function disposeMat(m){ ['map','normalMap','roughnessMap','metalnessMap','occlusionMap','emissiveMap'].forEach(k=>m[k]?.dispose?.()); }
function clearModel(){
  if(!current) return;
  scene.remove(current);
  current.traverse?.(o=>{ if(o.geometry) o.geometry.dispose(); const m=o.material; if(m) (Array.isArray(m)?m:[m]).forEach(disposeMat); });
  current = null; lastGLTF=null;
}
function triCount(obj){ let t=0; obj.traverse(o=>{ if(o.isMesh){ const g=o.geometry; if(g?.index) t+=g.index.count/3; else if(g?.attributes?.position) t+=g.attributes.position.count/3; }}); return Math.round(t); }

/* --- place() base --- */
function place(root){
  new THREE.Box3().setFromObject(root).getCenter(root.position).multiplyScalar(-1);
  const box = new THREE.Box3().setFromObject(root);
  const size = box.getSize(new THREE.Vector3());
  root.position.y -= box.min.y;

  current = root; scene.add(root);

  document.getElementById('stats').textContent =
    `Approx. tris: ${triCount(root).toLocaleString()} | Size: ${size.x.toFixed(2)} × ${size.y.toFixed(2)} × ${size.z.toFixed(2)} m`;

  const maxDim = Math.max(size.x,size.y,size.z);
  camera.position.setScalar(maxDim*1.6).setY(maxDim*0.8);
  controls.target.copy(new THREE.Box3().setFromObject(root).getCenter(new THREE.Vector3()));
  controls.update();

  buildVariantsGUI(); // si aplica
}

/* --- inteligencia por nombres --- */
const NAME = {
  wall:        (n)=>/^wall\d+$/i.test(n),          // solo nodos raiz wallN
  iwall:       (n)=>/^interiorwall\d+$/i.test(n),
  ceiling:     (n)=>/^ceiling\d+$/i.test(n),
  floor:       (n)=>/^floor\d+$/i.test(n),
  doorPanel:   (n)=>/(^|_)((leftpanel|rightpanel)\d+)$/i.test(n) // solo paneles, no hijos
};

function flatten(root){ const list=[]; root.traverse(o=>{ if(o.name) list.push(o); }); return list; }
function byNameExact(list, pred){ return list.filter(o => pred(o.name)); }

/* puertas */
function prepDoorPanels(list){
  const doors=[];
  list.forEach(o=>{
    // asegurar que no sean hijos de otras piezas con nombres compuestos
    const side = /leftpanel/i.test(o.name) ? 'left' : 'right';
    o.userData.closedQ = o.quaternion.clone();
    o.userData.sign    = side === 'left' ? +1 : -1; // +Y izq, -Y der
    doors.push(o);
  });
  return doors;
}
function setDoorAmount(o, amt){
  const maxDeg = 110;
  const rad = THREE.MathUtils.degToRad(maxDeg * o.userData.sign * amt);
  o.quaternion.copy(o.userData.closedQ);
  o.rotateY(rad);
}

/* auto-hide wall */
const raycaster = new THREE.Raycaster();
let autoHideWall = { enabled:false, hidden:null };

/* estado / GUI */
let STRUCT=null, DOORS=[];
function setGroupVisible(nodes, v){ nodes.forEach(n=> n.visible=v); }

/* envolver place para construir estructura + GUI por modelo */
const _placeOrig = place;
place = (root)=>{
  _placeOrig(root);

  const all       = flatten(root);

  // colecciones SOLO en nodos raíz que coincidan exactamente (sin children ni nombres compuestos)
  const walls     = byNameExact(all, NAME.wall);
  const iWalls    = byNameExact(all, NAME.iwall);
  const ceilings  = byNameExact(all, NAME.ceiling);
  const floors    = byNameExact(all, NAME.floor);
  const panels    = byNameExact(all, NAME.doorPanel);
  DOORS = prepDoorPanels(panels);

  // colliders (por nombre, cualquiera)
  const colliders = all.filter(o => /collider/i.test(o.name));

  STRUCT = {
    walls, iWalls, ceilings, floors, colliders,
    show: { walls:true, iWalls:true, ceilings:true, floors:true, colliders:false },
    doorsOpen: false,
    allNodes: all
  };

  setGroupVisible(walls,     STRUCT.show.walls);
  setGroupVisible(iWalls,    STRUCT.show.iWalls);
  setGroupVisible(ceilings,  STRUCT.show.ceilings);
  setGroupVisible(floors,    STRUCT.show.floors);
  setGroupVisible(colliders, STRUCT.show.colliders);

  buildStructureGUI();
  buildDoorsGUI();
  buildIsolateGUI();
};

function updateAutoHideWall(){
  if(!autoHideWall.enabled || !STRUCT?.walls?.length || !current) return;
  const dir = new THREE.Vector3().subVectors(controls.target, camera.position).normalize();
  raycaster.set(camera.position, dir);
  const hits = raycaster.intersectObjects(STRUCT.walls, true);
  const first = hits.find(h => h.object.visible !== false);
  const newWall = first ? findAncestorInSet(first.object, new Set(STRUCT.walls)) : null;
  if(newWall !== autoHideWall.hidden){
    if(autoHideWall.hidden) autoHideWall.hidden.visible = true;
    autoHideWall.hidden = newWall;
    if(autoHideWall.hidden) autoHideWall.hidden.visible = false;
  }
}
function findAncestorInSet(obj,set){ let p=obj; while(p && !set.has(p)) p=p.parent; return p||null; }

/* ---------- GUI ---------- */
const gui = new GUI({ title:'Viewer', width:330 });
gui.domElement.style.position='fixed';
gui.domElement.style.right='12px';
gui.domElement.style.top='12px';
gui.domElement.style.zIndex='20';

const ToneMapByName = {
  None: THREE.NoToneMapping,
  Linear: THREE.LinearToneMapping,
  Reinhard: THREE.ReinhardToneMapping,
  Cineon: THREE.CineonToneMapping,
  ACESFilmic: THREE.ACESFilmicToneMapping
};
const params = {
  exposure: renderer.toneMappingExposure,
  toneMapping: 'ACESFilmic',
  background: '#0b0d10',
  highQuality: true,
  wireframe: false,
  fov: camera.fov,
  autoRotate: false,
  autoRotateSpeed: 1.0,
  autoHideWall: false,
  env: 'Room',
  envURL: '',
  isolateQuery: ''
};

const fRender = gui.addFolder('Render');
fRender.add(params, 'exposure', 0.2, 2.5, 0.01).onChange(v=> renderer.toneMappingExposure=v);
fRender.add(params, 'toneMapping', Object.keys(ToneMapByName)).onChange(n=> renderer.toneMapping = ToneMapByName[n]);
fRender.addColor(params, 'background').onChange(v=> renderer.setClearColor(new THREE.Color(v)));
fRender.add(params, 'highQuality').name('High quality (HiDPI)').onChange(v=> renderer.setPixelRatio(v ? Math.min(devicePixelRatio,2) : 1));
fRender.add(params, 'wireframe').onChange(v=>{
  if(!current) return;
  current.traverse(o=>{
    if(o.isMesh && o.material){
      (Array.isArray(o.material)?o.material:[o.material]).forEach(m=> m.wireframe = v);
    }
  });
});

const fCam = gui.addFolder('Camera');
fCam.add(params, 'fov', 20, 90, 1).onChange(v=>{ camera.fov=v; camera.updateProjectionMatrix(); });
fCam.add(params, 'autoRotate').onChange(v=> controls.autoRotate=v);
fCam.add(params, 'autoRotateSpeed', -5, 5, 0.1).onChange(v=> controls.autoRotateSpeed=v);

/* Structure */
let _guiStructFolder=null, _guiDoorsFolder=null, _guiEnvFolder=null, _guiVariantsFolder=null, _guiIsolateFolder=null;

function buildStructureGUI(){
  _guiStructFolder?.destroy?.();
  _guiStructFolder = gui.addFolder('Structure');
  const S = STRUCT.show;
  _guiStructFolder.add(S, 'walls').name('Walls on').onChange(v=> setGroupVisible(STRUCT.walls, v));
  _guiStructFolder.add(S, 'iWalls').name('Interior walls on').onChange(v=> setGroupVisible(STRUCT.iWalls, v));
  _guiStructFolder.add(S, 'ceilings').name('Ceilings on').onChange(v=> setGroupVisible(STRUCT.ceilings, v));
  _guiStructFolder.add(S, 'floors').name('Floors on').onChange(v=> setGroupVisible(STRUCT.floors, v));
  _guiStructFolder.add(S, 'colliders').name('Colliders on').onChange(v=> setGroupVisible(STRUCT.colliders, v));
  _guiStructFolder.add(params, 'autoHideWall').name('Auto-hide front wall').onChange(v=>{
    autoHideWall.enabled = v;
    if(!v && autoHideWall.hidden){ autoHideWall.hidden.visible = true; autoHideWall.hidden=null; }
  });
}

/* Doors — toggle on/off */
function setAllDoorsOpen(open){
  const amt = open ? 1 : 0;
  DOORS.forEach(o=> setDoorAmount(o, amt));
}
function buildDoorsGUI(){
  _guiDoorsFolder?.destroy?.();
  _guiDoorsFolder = gui.addFolder('Doors');
  _guiDoorsFolder.add(STRUCT, 'doorsOpen').name('All doors open').onChange(v=> setAllDoorsOpen(v));
  // sliders individuales (opcional, dejalos para control fino)
  DOORS.forEach(o=>{
    const obj = { open: 0 };
    _guiDoorsFolder.add(obj, 'open', 0, 1, 0.01).name(o.name).onChange(v=> setDoorAmount(o, v));
  });
}

/* Environment / HDRI */
async function setEnvironmentHDR(url){
  try{
    const tex = await new RGBELoader().setDataType(THREE.UnsignedByteType).loadAsync(url);
    const env = pmrem.fromEquirectangular(tex).texture;
    tex.dispose();
    scene.environment = env;
    currentEnv = env;
  }catch(e){ console.error('HDR load error', e); }
}
function buildEnvGUI(){
  _guiEnvFolder?.destroy?.();
  _guiEnvFolder = gui.addFolder('Environment');
  const presets = ['Room','Neutral Grey (HDR)','Studio Small (HDR)','Custom URL'];
  _guiEnvFolder.add(params, 'env', presets).onChange(async v=>{
    if(v==='Room'){
      scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
    } else if(v==='Neutral Grey (HDR)'){
      await setEnvironmentHDR('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/neutral_wall_1k.hdr');
    } else if(v==='Studio Small (HDR)'){
      await setEnvironmentHDR('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr');
    } else {
      if(params.envURL) await setEnvironmentHDR(params.envURL);
    }
  });
  _guiEnvFolder.add(params, 'envURL').name('HDR URL').onFinishChange(async v=>{
    params.env='Custom URL';
    await setEnvironmentHDR(v);
  });
}
buildEnvGUI();

/* Variants (KHR_materials_variants) */
function buildVariantsGUI(){
  _guiVariantsFolder?.destroy?.();
  const ext = lastGLTF?.parser?.extensions?.KHR_materials_variants;
  if(!ext) return;
  _guiVariantsFolder = gui.addFolder('Variants');
  const names = ext.variants?.map(v=>v.name) || [];
  const sel = { variant: names[0] || '' };
  if(!names.length) return;
  _guiVariantsFolder.add(sel, 'variant', names).onChange(name=>{
    try{ ext.selectVariant(current, name); }catch(e){ console.warn('Variant switch error', e); }
  });
}

/* Isolate */
function buildIsolateGUI(){
  _guiIsolateFolder?.destroy?.();
  _guiIsolateFolder = gui.addFolder('Isolate');
  const api = {
    query: '',
    isolate(){
      if(!STRUCT?.allNodes) return;
      const rx = new RegExp(api.query, 'i');
      const keep = STRUCT.allNodes.filter(n=> rx.test(n.name));
      const keepSet = new Set(keep);
      current.traverse(o=>{
        let visible = keepSet.has(o);
        // mantener ancestros de keep
        keep.forEach(n=>{
          let p=n.parent; while(p){ if(p===o) visible=true; p=p.parent; }
        });
        if(o!==current) o.visible = visible;
      });
    },
    clear(){
      if(!current) return;
      current.traverse(o=> o.visible=true);
    }
  };
  _guiIsolateFolder.add(api, 'query').name('Name contains');
  _guiIsolateFolder.add(api, 'isolate').name('Apply isolate');
  _guiIsolateFolder.add(api, 'clear').name('Clear isolate');
}

/* --- carga --- */
function setMsg(t){ document.getElementById('msg').textContent = t || ''; }
function loadFromURL(url){
  setMsg('Loading…'); clearModel();
  loader.load(url, gltf=>{
    lastGLTF = gltf;
    place(gltf.scene); setMsg('Loaded');
  }, xhr=>{ if(xhr.total) setMsg(`Loading ${(xhr.loaded/xhr.total*100).toFixed(0)}%`); },
  err=>{ console.error(err); setMsg('Error loading model'); });
}
async function loadLocal(file){
  try{
    setMsg('Reading…'); clearModel();
    const buf = await file.arrayBuffer();
    loader.parse(buf, '', gltf=>{
      lastGLTF = gltf;
      place(gltf.scene); setMsg(file.name);
    }, err=>{ console.error(err); setMsg('Error parsing GLB'); });
  }catch(e){ console.error(e); setMsg('Error reading file'); }
}
document.getElementById('loadBtn').onclick=()=>{
  const u=document.getElementById('url').value.trim();
  if(u) loadFromURL(u);
};
const fileInput=document.getElementById('fileInput');
document.getElementById('fileBtn').onclick=()=>{ fileInput.value=''; fileInput.click(); };
fileInput.onchange=()=>{ const f=fileInput.files?.[0]; if(f) loadLocal(f); };

const modelURL=new URLSearchParams(location.search).get('model');
if(modelURL){ document.getElementById('url').value=modelURL; loadFromURL(modelURL); }

/* --- loop --- */
function resize(){
  const w=innerWidth,h=innerHeight;
  renderer.setSize(w,h,false);
  camera.aspect=w/h; camera.updateProjectionMatrix();
}
addEventListener('resize', resize);
resize();

renderer.setAnimationLoop(()=>{
  controls.update();
  if(params.autoHideWall) updateAutoHideWall();
  renderer.render(scene,camera);
});
</script>
</body>
</html>
