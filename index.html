<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Room Viewer</title>
<style>
  body { margin: 0; background: #c9c9c9; overflow: hidden; }
  #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.5); color: white; padding: 10px; font-family: sans-serif; }
  label { display: block; margin-top: 5px; }
</style>
</head>
<body>
<div id="ui">
  <label><input type="checkbox" id="aoEnable" checked> Enable AO</label>
  <label>AO Strength: <input type="range" id="aoStrength" min="0" max="1" step="0.05" value="1"></label>
</div>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/loaders/GLTFLoader.js';
import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/loaders/RGBELoader.js';

let camera, scene, renderer, controls;
let current = null;

init();
loadModel('room.glb'); // Cambia por tu GLB

function init(){
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(3, 2, 3);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0,1,0);
  controls.update();

  // HDRI bÃ¡sica
  new RGBELoader().load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/neutral_wall_1k.hdr', tex=>{
    tex.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = tex;
    scene.background = new THREE.Color(0xc9c9c9);
  });

  window.addEventListener('resize', onWindowResize);
  animate();
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function loadModel(url){
  const loader = new GLTFLoader();
  loader.load(url, gltf=>{
    if(current) scene.remove(current);
    current = gltf.scene;

    // Ocultar techo por default
    current.traverse(o=>{
      if(o.isMesh){
        if(/ceiling/i.test(o.name)){
          o.visible = false;
        }
      }
    });

    // Fix uv2 si hay AO
    current.traverse(o=>{
      if (!o.isMesh) return;
      const mats = Array.isArray(o.material) ? o.material : [o.material];
      mats.forEach(mm=>{
        if (mm && mm.aoMap && o.geometry && !o.geometry.attributes.uv2 && o.geometry.attributes.uv) {
          o.geometry.setAttribute('uv2', o.geometry.attributes.uv);
        }
      });
    });

    scene.add(current);
    applyAOtoScene(parseFloat(aoStrength.value), aoEnable.checked);
  });
}

function patchAlbedoAO(mat, strength, enabled){
  if(!enabled){
    if(mat.userData._aoPatched){
      delete mat.onBeforeCompile;
      delete mat.userData._aoPatched;
      delete mat.userData._uAo;
      mat.needsUpdate = true;
    }
    return;
  }
  const uRef = mat.userData._uAo || (mat.userData._uAo = { value: strength });
  uRef.value = strength;

  mat.userData._aoPatched = true;
  mat.onBeforeCompile = (shader)=>{
    shader.fragmentShader = 'uniform float uAoStrength;\n' + shader.fragmentShader;
    shader.uniforms.uAoStrength = uRef;

    shader.fragmentShader = shader.fragmentShader.replace(
      '#include <aomap_fragment>',
`#ifdef USE_AOMAP
  float ambientOcclusion = texture2D( aoMap, vAoMapUv ).r;
#else
  float ambientOcclusion = 1.0;
#endif
`
    );

    shader.fragmentShader = shader.fragmentShader.replace(
      '#include <output_fragment>',
`diffuseColor.rgb *= mix(1.0, ambientOcclusion, uAoStrength);
#include <output_fragment>`
    );
  };
  mat.needsUpdate = true;
}

function applyAOtoScene(strength, enabled){
  if(!current) return;
  current.traverse(o=>{
    if(!o.isMesh) return;
    const mats = Array.isArray(o.material)? o.material : [o.material];
    mats.forEach(m=>{
      if(!(m && (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial))) return;
      if(m.userData?._aoPatched && m.userData._uAo){
        m.userData._uAo.value = strength;
        m.needsUpdate = true;
      } else {
        patchAlbedoAO(m, strength, enabled);
      }
    });
  });
}

aoEnable.addEventListener('change', ()=>{
  applyAOtoScene(parseFloat(aoStrength.value), aoEnable.checked);
});
aoStrength.addEventListener('input', ()=>{
  applyAOtoScene(parseFloat(aoStrength.value), aoEnable.checked);
});

function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>
</body>
</html>

