<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Room Viewer</title>

<!-- Import map: resuelve "three" y los addons en GitHub Pages -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.164/examples/jsm/"
  }
}
</script>

<style>
  html,body{height:100%;margin:0}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;background:#c9c9c9;color:#222}
  #topbar{position:fixed;inset:12px 12px auto 12px;display:flex;gap:8px;align-items:center;background:rgba(255,255,255,.85);backdrop-filter:blur(6px);border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:10px 12px;z-index:10}
  #topbar input,#topbar select{background:#f5f5f5;border:1px solid #ccc;color:#111;border-radius:6px;padding:6px 8px}
  #topbar button{background:#1e68ff;border:none;color:white;padding:6px 10px;border-radius:6px;cursor:pointer}
  #topbar small{opacity:.7}
  #fileInput{display:none}
  #stats{position:fixed;inset:auto 12px 12px 12px;background:rgba(255,255,255,.85);border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:8px 12px;display:flex;gap:16px;flex-wrap:wrap}
  #drop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;border:2px dashed #2a2f36;border-radius:16px;background:rgba(30,104,255,.08);color:#1e68ff;pointer-events:auto}
  canvas{display:block;width:100%;height:100%}
</style>
</head>
<body>
  <div id="topbar">
    <small>GLB URL</small>
    <input id="url" placeholder="https://example.com/model.glb" />
    <button id="loadBtn">Load</button>
    <button id="fileBtn">Open .glb</button>
    <input type="file" id="fileInput" accept=".glb,model/gltf-binary" />
    <label><input type="checkbox" id="doorsToggle"> All Doors Open</label>
    <label><input type="checkbox" id="autoHideToggle" checked> Auto-hide wall</label>
    <label>AO:
      <select id="aoMode">
        <option value="LightOnly">Light only</option>
        <option value="Albedo×AO">Albedo × AO</option>
      </select>
    </label>
    <label>Strength <input type="range" id="aoStrength" min="0" max="1" step="0.01" value="0.6"></label>
    <label>HDR
      <select id="hdrSelect">
        <option value="">Room (default)</option>
        <option value="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr">Studio Small</option>
        <option value="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/neutral_wall_1k.hdr">Neutral Grey</option>
      </select>
    </label>
    <small id="msg"></small>
  </div>
  <div id="stats"></div>
  <div id="drop">Drop a .glb file to view</div>
  <canvas id="c"></canvas>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }   from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader }  from 'three/addons/loaders/DRACOLoader.js';
import { KTX2Loader }   from 'three/addons/loaders/KTX2Loader.js';
import { RGBELoader }   from 'three/addons/loaders/RGBELoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

/* ---- renderer / scene / camera ---- */
const canvas   = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping      = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(devicePixelRatio,2));

const scene  = new THREE.Scene();
scene.background = new THREE.Color(0xc9c9c9);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(2,1.2,2);

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,0.6,0);
controls.enableDamping = true;

// iluminación integral (sin direccional)
scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.0));
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

/* ---- loaders ---- */
const draco  = new DRACOLoader().setDecoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/draco/');
const ktx2   = new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/basis/').detectSupport(renderer);
const loader = new GLTFLoader().setDRACOLoader(draco).setKTX2Loader(ktx2);

/* ---- state ---- */
let current=null, allNodes=[], doorPanels=[], lastHiddenWall=null;
const MAX_DOOR_DEG = 90;

/* ---- utils ---- */
function setMsg(t){ document.getElementById('msg').textContent=t||''; }
function disposeMat(m){ ['map','normalMap','roughnessMap','metalnessMap','occlusionMap','emissiveMap'].forEach(k=>m[k]?.dispose?.()); }
function clearModel(){
  if(!current) return;
  scene.remove(current);
  current.traverse?.(o=>{ if(o.geometry) o.geometry.dispose(); const m=o.material; if(m) (Array.isArray(m)?m:[m]).forEach(disposeMat); });
  current=null; allNodes=[]; doorPanels=[]; lastHiddenWall=null;
}
function triCount(obj){ let t=0; obj.traverse(o=>{ if(o.isMesh){ const g=o.geometry; if(g?.index) t+=g.index.count/3; else if(g?.attributes?.position) t+=g.attributes.position.count/3; }}); return Math.round(t); }

/* ---- AO patch (seguro) ---- */
function patchStandardAO(mat, mode, strength, enabled){
  if(!enabled){
    if(mat.userData._aoPatched){
      delete mat.onBeforeCompile;
      delete mat.userData._aoPatched;
      delete mat.userData._uAo;
      mat.needsUpdate = true;
    }
    return;
  }
  const uRef = mat.userData._uAo || (mat.userData._uAo = { value: strength });
  uRef.value = strength;

  mat.userData._aoPatched = true;
  mat.onBeforeCompile = (shader)=>{
    shader.fragmentShader = 'uniform float uAoStrength;\n' + shader.fragmentShader;
    shader.uniforms.uAoStrength = uRef;

    if (mode === 'Albedo×AO') shader.defines.ENABLE_ALBEDO_AO = 1;
    else delete shader.defines.ENABLE_ALBEDO_AO;

    shader.fragmentShader = shader.fragmentShader.replace(
      '#include <aomap_fragment>',
`#include <aomap_fragment>
#ifdef USE_AOMAP
  reflectedLight.indirectDiffuse = mix( reflectedLight.indirectDiffuse,
                                        reflectedLight.indirectDiffuse * ambientOcclusion,
                                        uAoStrength );
#endif
`
    );
    shader.fragmentShader = shader.fragmentShader.replace(
      '#include <output_fragment>',
`#ifdef USE_AOMAP
  float _aoSample = ambientOcclusion;
#else
  float _aoSample = 1.0;
#endif
#ifdef ENABLE_ALBEDO_AO
  diffuseColor.rgb *= mix(1.0, _aoSample, uAoStrength);
#endif
#include <output_fragment>`
    );
  };
  mat.needsUpdate = true;
}
function applyAOToMaterials(mode, strength, enabled){
  if(!current) return;
  current.traverse(o=>{
    if(!o.isMesh) return;
    const mats = Array.isArray(o.material) ? o.material : [o.material];
    mats.forEach(m=>{
      if(m && (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial)){
        if(m.userData?._aoPatched && m.userData._uAo){
          m.userData._uAo.value = strength;  // live
          m.needsUpdate = true;
        } else {
          patchStandardAO(m, mode, strength, enabled);
        }
      }
    });
  });
}

/* ---- placing model ---- */
function place(root){
  // ocultar colliders
  root.traverse(o=>{ if(o.isMesh && /collider/i.test(o.name)) o.visible=false; });

  // centrar, apoyar
  new THREE.Box3().setFromObject(root).getCenter(root.position).multiplyScalar(-1);
  const box = new THREE.Box3().setFromObject(root), size = box.getSize(new THREE.Vector3());
  root.position.y -= box.min.y;

  // recolectar nodos con nombre + preparar puertas y walls
  allNodes=[];
  root.traverse(o=>{ if(o.name) allNodes.push(o); });

  const panelsRaw = allNodes.filter(o => /(leftpanel|rightpanel)\d+/i.test(o.name));
  doorPanels = panelsRaw.map(o=>{
    const left = /leftpanel/i.test(o.name);
    o.userData.closedQ = o.quaternion.clone();
    o.userData.sign    = left ? +1 : -1; // +Y izq, -Y der
    return o;
  });

  current = root;
  scene.add(root);

  document.getElementById('stats').textContent =
    `Approx. tris: ${triCount(root).toLocaleString()} | Size: ${size.x.toFixed(2)} × ${size.y.toFixed(2)} × ${size.z.toFixed(2)} m`;

  const maxDim = Math.max(size.x,size.y,size.z);
  camera.position.setScalar(maxDim*1.6).setY(maxDim*0.8);
  controls.target.copy(new THREE.Box3().setFromObject(root).getCenter(new THREE.Vector3()));
  controls.update();

  // aplicar AO al nuevo modelo
  applyAOToMaterials(aoMode.value, parseFloat(aoStrength.value), true);
}

/* ---- doors ---- */
function setDoor(o, amt){ // amt [0..1], clamp 90°
  const rad = THREE.MathUtils.degToRad(MAX_DOOR_DEG * o.userData.sign * THREE.MathUtils.clamp(amt,0,1));
  o.quaternion.copy(o.userData.closedQ);
  o.rotateY(rad);
}
function toggleDoors(open){ doorPanels.forEach(o=> setDoor(o, open?1:0)); }

/* ---- auto-hide wall (ray desde cámara al target) ---- */
const ray = new THREE.Raycaster();
function asWallRoot(obj){
  let p=obj; while(p){ if(/^wall\d+$/i.test(p.name)) return p; p=p.parent; }
  return null;
}
function updateAutoHide(){
  const enabled = document.getElementById('autoHideToggle').checked;
  if(!enabled || !current) return;

  const dir = new THREE.Vector3().subVectors(controls.target, camera.position).normalize();
  ray.set(camera.position, dir);

  const hits = ray.intersectObject(current, true);
  let newWall=null;
  for(const h of hits){
    if(h.object.visible === false) continue;
    const wr = asWallRoot(h.object);
    if(wr){ newWall = wr; break; }
  }
  if(newWall !== lastHiddenWall){
    if(lastHiddenWall) lastHiddenWall.visible = true;
    lastHiddenWall = newWall;
    if(lastHiddenWall) lastHiddenWall.visible = false;
  }
}

/* ---- loading ---- */
function loadFromURL(url){
  setMsg('Loading…'); clearModel();
  loader.load(url, g=>{ place(g.scene); setMsg('Loaded'); },
    xhr=>{ if(xhr.total) setMsg(`Loading ${(xhr.loaded/xhr.total*100).toFixed(0)}%`); },
    err=>{ console.error(err); setMsg('Error loading model'); });
}
function loadBlob(file){
  setMsg('Loading local file…'); clearModel();
  const url = URL.createObjectURL(file);
  loader.load(url, g=>{ place(g.scene); setMsg(file.name); URL.revokeObjectURL(url); },
    undefined, e=>{ console.error(e); setMsg('Error with local file'); });
}

/* ---- UI wire-up ---- */
const urlInput=document.getElementById('url');
document.getElementById('loadBtn').onclick = ()=>{ const u=urlInput.value.trim(); if(u) loadFromURL(u); };

const fileInput=document.getElementById('fileInput');
document.getElementById('fileBtn').onclick = ()=>{ fileInput.value=''; fileInput.click(); };
fileInput.onchange = ()=>{ const f=fileInput.files?.[0]; if(f) loadBlob(f); };

document.getElementById('doorsToggle').onchange = e=> toggleDoors(e.target.checked);
const aoMode     = document.getElementById('aoMode');
const aoStrength = document.getElementById('aoStrength');
aoMode.onchange      = ()=> applyAOToMaterials(aoMode.value, parseFloat(aoStrength.value), true);
aoStrength.oninput   = ()=> applyAOToMaterials(aoMode.value, parseFloat(aoStrength.value), true);

document.getElementById('hdrSelect').onchange = (e)=>{
  const v=e.target.value;
  if(!v){ scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture; return; }
  new RGBELoader().load(v, tex=>{
    const env = pmrem.fromEquirectangular(tex).texture;
    scene.environment = env;
    tex.dispose();
  }, undefined, err=> console.warn('HDR load error', err));
};

/* ---- drag & drop ---- */
const drop=document.getElementById('drop');
['dragenter','dragover','dragleave','drop'].forEach(ev=>{
  window.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); }, false);
});
window.addEventListener('dragenter', ()=> drop.style.display='flex');
window.addEventListener('dragover',  ()=> drop.style.display='flex');
window.addEventListener('dragleave', e=>{
  if(e.clientX<=0||e.clientY<=0||e.clientX>=innerWidth||e.clientY>=innerHeight){ drop.style.display='none'; }
});
function handleDrop(e){ drop.style.display='none'; const f=e.dataTransfer?.files?.[0]; if(f) loadBlob(f); }
drop.addEventListener('drop', handleDrop);
document.addEventListener('drop', handleDrop);

/* ---- query param ?model= ---- */
const modelURL=new URLSearchParams(location.search).get('model');
if(modelURL){ urlInput.value=modelURL; loadFromURL(modelURL); }

/* ---- resize / loop ---- */
function resize(){
  const w=innerWidth,h=innerHeight;
  renderer.setSize(w,h,false);
  camera.aspect=w/h; camera.updateProjectionMatrix();
}
addEventListener('resize', resize);
resize(); // <- ahora se llama DESPUÉS de crear camera (fix del error)

renderer.setAnimationLoop(()=>{
  controls.update();
  updateAutoHide();
  renderer.render(scene,camera);
});
</script>
</body>
</html>
