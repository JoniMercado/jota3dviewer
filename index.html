<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Room Viewer — v0.1.3</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.164/examples/jsm/"
  }
}
</script>

<style>
  html,body{height:100%;margin:0}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;background:#c9c9c9;color:#222}

  #topbar{
    position:fixed;inset:12px auto auto 12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    background:rgba(255,255,255,.85);backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:10px 12px;z-index:10
  }
  #topbar input{background:#f5f5f5;border:1px solid #ccc;color:#111;border-radius:6px;padding:6px 8px}
  #topbar button{background:#1e68ff;border:none;color:white;padding:6px 10px;border-radius:6px;cursor:pointer}
  #topbar small{opacity:.7}
  #fileInput{display:none}
  #logo{height:48px;margin-right:12px;border-radius:6px}

  #sidepanel{position:fixed;right:12px;top:12px;width:280px;max-height:calc(100% - 24px);display:flex;flex-direction:column;gap:8px;overflow:auto;z-index:9}
  .card{background:rgba(255,255,255,.9);backdrop-filter:blur(6px);border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:10px 12px}
  details.asset-anim{border:1px solid rgba(0,0,0,.08);border-radius:10px;background:#fff}
  details.asset-anim>summary{list-style:none;cursor:pointer;padding:8px 10px;border-radius:10px;background:#f9f9f9;border:1px solid rgba(0,0,0,.06);font-weight:600;font-size:14px}
  details.asset-anim[open]>summary{background:#f3f6ff;border-color:#ccd9ff}
  .anim-panel{padding:8px 10px}
  .anim-group{display:flex;align-items:center;gap:8px;margin-top:8px;flex-wrap:wrap}
  .anim-group-name{font-size:12px;opacity:.8;padding:2px 6px;background:#f2f2f2;border-radius:6px}
  .anim-slider{width:160px}
  .muted{opacity:.7;font-size:12px}

  #stats{position:fixed;inset:auto 12px 12px 12px;background:rgba(255,255,255,.85);border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:8px 12px;display:flex;gap:16px;flex-wrap:wrap}
  #drop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;border:2px dashed #2a2f36;border-radius:16px;background:rgba(30,104,255,.08);color:#1e68ff;pointer-events:auto;z-index:999}
  canvas{display:block;width:100%;height:100%}
  label{display:flex;align-items:center;gap:6px}

  /* Medidas (overlay SVG) */
  #measureOverlay{position:fixed;inset:0;pointer-events:none;z-index:8;filter: drop-shadow(0 1px 0 rgba(0,0,0,.2));}
  .m-line{stroke:#2b60ff;stroke-width:2;fill:none}
  .m-arrow{stroke:#2b60ff;stroke-width:2;fill:none;marker-end:url(#arrow)}
  .m-badge{fill:white;stroke:#2b60ff;stroke-width:2}
  .m-text{font:12px/1.2 system-ui,Segoe UI,Roboto,Arial;color:#2b60ff;fill:#2b60ff;text-anchor:middle;dominant-baseline:middle}

  @media (max-width: 960px){ #sidepanel{width:240px} }
</style>
</head>
<body>
  <div id="topbar">
    <img id="logo" src="https://jonimercado.github.io/threejs-viewer/jota%203d.jpg" alt="Logo">
    <small>GLB/GLTF URL</small>
    <input id="url" placeholder="https://example.com/model.glb" />
    <button id="loadBtn">Load</button>
    <button id="fileBtn">Open .glb/.gltf</button>
    <input type="file" id="fileInput" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" />

    <!-- Rooms controls (ocultos por default) -->
    <label style="display:none"><input type="checkbox" id="doorsToggle"> All Doors Open</label>
    <label style="display:none"><input type="checkbox" id="autoHideToggle" checked> Auto-hide front wall</label>
    <label style="display:none"><input type="checkbox" id="hideCeilingToggle" checked> Hide ceiling</label>

    <small id="msg"></small>
  </div>

  <div id="sidepanel" style="display:none"></div>
  <svg id="measureOverlay"></svg>
  <div id="stats"></div>
  <div id="drop">Drop a .glb / .gltf file to view</div>
  <canvas id="c"></canvas>

  <!-- Password Gate -->
  <div id="gate" style="position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:2000;">
    <div style="background:#fff;padding:20px 16px;border-radius:14px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.2);display:grid;gap:10px">
      <div style="font-weight:700">Ingresar</div>
      <input id="gateInput" type="password" placeholder="Password" style="padding:8px 10px;border:1px solid #ddd;border-radius:8px">
      <button id="gateBtn" style="background:#1e68ff;color:#fff;border:none;border-radius:8px;padding:8px 10px;cursor:pointer">Entrar</button>
      <small id="gateMsg" style="color:#c00;min-height:1em"></small>
    </div>
  </div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }     from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader }    from 'three/addons/loaders/DRACOLoader.js';
import { KTX2Loader }     from 'three/addons/loaders/KTX2Loader.js';
import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
import { RoomEnvironment }from 'three/addons/environments/RoomEnvironment.js';

/* ---------- password gate ---------- */
const VIEWER_PASSWORD = 'demo';
const gate   = document.getElementById('gate');
const gInput = document.getElementById('gateInput');
const gBtn   = document.getElementById('gateBtn');
const gMsg   = document.getElementById('gateMsg');
function passOK(p){
  const urlKey = new URLSearchParams(location.search).get('key');
  return (p && p === VIEWER_PASSWORD) || (urlKey && urlKey === VIEWER_PASSWORD);
}
function unlock(){ gate.style.display = 'none'; localStorage.setItem('viewer_ok','1'); }
(function initGate(){
  if(localStorage.getItem('viewer_ok') === '1' || passOK(null)){ unlock(); }
  else{
    gBtn?.addEventListener('click', ()=>{ if(passOK(gInput.value)) unlock(); else gMsg.textContent='Password incorrecta'; });
    gInput?.addEventListener('keydown', (e)=>{ if(e.key==='Enter') gBtn.click(); });
  }
})();

/* ---------- renderer / scene / camera ---------- */
const canvas   = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping      = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type    = THREE.PCFSoftShadowMap;

const scene  = new THREE.Scene();
scene.background = new THREE.Color(0xc9c9c9);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(2,1.2,2);

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,0.6,0);
controls.enableDamping = true;

scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.0));
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

/* Luz direccional para sombras (modo asset) */
let dirLight = null;

/* ---------- loaders ---------- */
const draco  = new DRACOLoader().setDecoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/draco/');
const ktx2   = new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/basis/').detectSupport(renderer);
const loader = new GLTFLoader().setDRACOLoader(draco).setKTX2Loader(ktx2);

/* ---------- state ---------- */
let current = null;
let allNodes = [], doorPanels = [], doorVariantPairs = [], ceilings = [], wallRoots = [];
let lastHiddenWalls = new Set();

/* Asset UI state */
let assetRoot = null;
let animGroups = [];
let shadowPlane = null;
let dimsToggle = null; // checkbox "Mostrar medidas"

/* ---------- UI mode ---------- */
function setUIMode(mode){
  const lab = id => document.getElementById(id)?.closest('label');
  const doors = lab('doorsToggle');
  const autoH = lab('autoHideToggle');
  const ceil  = lab('hideCeilingToggle');
  const side  = document.getElementById('sidepanel');
  const svg   = document.getElementById('measureOverlay');

  if(mode === 'clean'){
    if(doors) doors.style.display = 'none';
    if(autoH) autoH.style.display = 'none';
    if(ceil)  ceil.style.display  = 'none';
    side.style.display = 'none';
    svg.style.display  = 'none';
    removeShadowSystem();
    return;
  }
  const isAsset = (mode === 'asset');
  if(doors) doors.style.display = isAsset ? 'none' : '';
  if(autoH) autoH.style.display = isAsset ? 'none' : '';
  if(ceil)  ceil.style.display  = isAsset ? 'none' : '';
  side.style.display = '';
  // mostrar SVG sólo si es asset y el toggle está activo
  const showDims = isAsset && (dimsToggle?.checked ?? true);
  svg.style.display  = showDims ? '' : 'none';
  if(!isAsset) removeShadowSystem();
}
setUIMode('clean');

/* ---------- helpers ---------- */
function setMsg(t){ document.getElementById('msg').textContent = t || ''; }
function disposeMat(m){ ['map','normalMap','roughnessMap','metalnessMap','occlusionMap','emissiveMap'].forEach(k=>m[k]?.dispose?.()); }
function clearModel(){
  if(!current) return;
  scene.remove(current);
  current.traverse?.(o=>{ if(o.geometry) o.geometry.dispose(); const m=o.material; if(m) (Array.isArray(m)?m:[m]).forEach(disposeMat); });
  current=null; allNodes=[]; doorPanels=[]; doorVariantPairs=[]; ceilings=[]; wallRoots=[]; lastHiddenWalls.clear();
  removeAssetUI(); clearMeasureOverlay(); removeShadowSystem();
}
function triCount(obj){ let t=0; obj.traverse(o=>{ if(o.isMesh){ const g=o.geometry; t += g?.index ? g.index.count/3 : (g?.attributes?.position?.count||0)/3; }}); return Math.round(t); }
function updateStats(sizeVec){
  const tris = current ? triCount(current).toLocaleString() : '—';
  const sz   = sizeVec ? `${sizeVec.x.toFixed(2)} × ${sizeVec.y.toFixed(2)} × ${sizeVec.z.toFixed(2)} m` : '—';
  document.getElementById('stats').textContent = `Tris: ${tris} | Size: ${sz}`;
}
function extractIndex(name){
  if(!name) return null;
  let match = name.match(/door(\d+)/i); if(match) return match[1];
  match = name.match(/panel(\d+)/i);    if(match) return match[1];
  match = name.match(/(\d+)(?!.*\d)/);  return match ? match[1] : null;
}
function extractSide(name){
  if(!name) return null;
  if(/leftpanel/i.test(name) || /_left/i.test(name)) return 'left';
  if(/rightpanel/i.test(name) || /_right/i.test(name)) return 'right';
  return null;
}
function doorGroupKey(name){
  if(!name) return '';
  const m = name.match(/^(.*?_door\d+)/i);
  if(m) return m[1].toLowerCase();
  const m2 = name.match(/^(.*?)(?:_(?:open|closed))?(?:leftpanel|rightpanel)\d+/i);
  if(m2) return m2[1].toLowerCase();
  return name.toLowerCase();
}
function guessModeFromFilename(name){
  if(!name) return null;
  const lower = name.toLowerCase();
  if(/_(00|0[0-9])\.(glb|gltf)$/.test(lower)) return 'room';
  return null;
}
function reparentKeepWorld(child, newParent){
  child.updateMatrixWorld(true);
  const childWorld = child.matrixWorld.clone();
  newParent.updateMatrixWorld(true);
  newParent.add(child);
  const invParentWorld = newParent.matrixWorld.clone().invert();
  const local = new THREE.Matrix4().multiplyMatrices(invParentWorld, childWorld);
  local.decompose(child.position, child.quaternion, child.scale);
  child.updateMatrixWorld(true);
}

/* ---------- puertas ---------- */
function findDoorPanels(nodes){
  const panels = nodes.filter(o => /(leftpanel|rightpanel)\d+$/i.test(o.name) && !/_open|_closed/i.test(o.name));
  return panels.map(o=>{
    const left = /leftpanel/i.test(o.name);
    o.userData.closedQ  = o.quaternion.clone();
    o.userData.sign     = left ? +1 : -1;
    o.userData.groupKey = doorGroupKey(o.name);
    o.userData.idx      = extractIndex(o.name);
    o.userData.side     = left ? 'left' : 'right';
    return o;
  });
}
function findDoorVariantPairs(nodes){
  const map = new Map();
  nodes.forEach(o=>{
    const m = o.name.match(/_(open|closed)(leftpanel|rightpanel)(\d+)$/i);
    if(!m) return;
    const state = m[1].toLowerCase();
    const side  = m[2].toLowerCase();
    const idx   = m[3];
    const group = doorGroupKey(o.name);
    const key   = `${group}|${side}|${idx}`;
    if(!map.has(key)) map.set(key, { open:null, closed:null, group, side, idx });
    map.get(key)[state] = o;
  });
  return Array.from(map.values()).filter(p => p.open || p.closed);
}
function getDoorRootsByIndex(groupKeyPref, idx, sidePref){
  const roots = [];
  doorPanels.forEach(d=>{
    const di   = d.userData.idx ?? extractIndex(d.name);
    const side = d.userData.side ?? extractSide(d.name);
    const gk   = d.userData.groupKey ?? doorGroupKey(d.name);
    if(String(di) === String(idx)
      && (!sidePref || sidePref===side)
      && (!groupKeyPref || groupKeyPref===gk)) roots.push(d);
  });
  doorVariantPairs.forEach(pair=>{
    const { open, closed, group, side, idx:pi } = pair;
    [open, closed].filter(Boolean).forEach(n=>{
      const di = pi ?? extractIndex(n.name);
      const gk = group ?? doorGroupKey(n.name);
      const sd = side  ?? extractSide(n.name);
      if(String(di) === String(idx)
        && (!sidePref || sidePref===sd)
        && (!groupKeyPref || groupKeyPref===gk)) roots.push(n);
    });
  });
  return roots;
}
function pickPreferredDoorRoot(idx, sidePref, groupKeyPref){
  const roots = getDoorRootsByIndex(groupKeyPref, idx, sidePref);
  if(!roots.length){
    const anyGroup = getDoorRootsByIndex(null, idx, sidePref);
    if(anyGroup.length) return anyGroup.find(r=>r.visible===true) || anyGroup[0];
    const anySideAnyGroup = getDoorRootsByIndex(null, idx, null);
    if(anySideAnyGroup.length) return anySideAnyGroup.find(r=>r.visible===true) || anySideAnyGroup[0];
    return null;
  }
  return roots.find(r=>r.visible===true) || roots[0];
}
function reparentHardwareToDoors(nodes, _doorPanels){
  const hardware = nodes.filter(o => /(handle|hinge|knob|hardware)/i.test(o.name));
  hardware.forEach(h=>{
    const idx          = extractIndex(h.name);
    const sidePref     = extractSide(h.name);
    const groupKeyPref = doorGroupKey(h.name);

    let target = (idx!=null) ? pickPreferredDoorRoot(idx, sidePref, groupKeyPref) : null;

    if(!target){
      let candidates = _doorPanels;
      const sameGroup = _doorPanels.filter(d => (d.userData.groupKey ?? doorGroupKey(d.name)) === groupKeyPref);
      if(sameGroup.length) candidates = sameGroup;
      if(sidePref){
        const filtered = candidates.filter(d=> (d.userData.side ?? extractSide(d.name))===sidePref);
        if(filtered.length) candidates = filtered;
      }
      let best=null, bestDist=Infinity;
      const hp = new THREE.Vector3(); new THREE.Box3().setFromObject(h).getCenter(hp);
      candidates.forEach(d=>{
        const dp = new THREE.Vector3(); new THREE.Box3().setFromObject(d).getCenter(dp);
        const dist = hp.distanceTo(dp);
        if(dist<bestDist){ bestDist=dist; best=d; }
      });
      target = best;
    }

    if(target && h.parent !== target) reparentKeepWorld(h, target);
  });
}
function enforceDoorVariantExclusivity(defaultState='closed'){
  doorVariantPairs.forEach(({open, closed})=>{
    if(open && closed){
      open.visible   = (defaultState === 'open');
      closed.visible = (defaultState === 'closed');
    }else if(open){
      open.visible = (defaultState === 'open');
    }else if(closed){
      closed.visible = (defaultState === 'closed');
    }
  });
}

/* ---------- Asset UI (anim_) ---------- */
function removeAssetUI(){ animGroups = []; dimsToggle = null; document.getElementById('sidepanel').innerHTML = ''; }
function collectMorphMeshes(root){
  const out = [];
  root.traverse(o=>{ if(o.isMesh && o.morphTargetInfluences && o.morphTargetDictionary){ out.push(o); }});
  return out;
}
function uniqueNamesFromMeshes(meshes){
  const set = new Set();
  meshes.forEach(m=>{ const d=m.morphTargetDictionary; if(!d) return; Object.keys(d).forEach(k=>set.add(k)); });
  return Array.from(set);
}
function findAnimRoots(asset){
  const arr=[]; asset.traverse(o=>{ if(o!==asset && o.name && /^anim_/i.test(o.name)) arr.push(o); });
  return arr;
}
function buildAnimUI(){
  if(!animGroups.length) return;
  const side = document.getElementById('sidepanel');
  const wrap = document.createElement('details'); wrap.className='asset-anim card'; wrap.open=true;
  const summary = document.createElement('summary'); summary.textContent='Accionables'; wrap.appendChild(summary);
  const inner = document.createElement('div'); inner.className='anim-panel'; wrap.appendChild(inner);

  // Toggle de medidas
  const dimsRow = document.createElement('label');
  dimsRow.style.cssText='display:flex;align-items:center;gap:6px;margin-top:6px;';
  dimsRow.innerHTML = '<input type="checkbox" id="toggleDims" checked> Mostrar medidas';
  inner.appendChild(dimsRow);
  dimsToggle = dimsRow.querySelector('#toggleDims');
  dimsToggle.addEventListener('change', ()=>{
    const svg = document.getElementById('measureOverlay');
    if(!dimsToggle.checked){ svg.style.display='none'; }
    else { svg.style.display=''; updateMeasureOverlay(); }
  });

  const info = document.createElement('div'); info.className='muted'; info.textContent='Shape keys por grupo (prefijo anim_)'; inner.appendChild(info);

  animGroups.forEach(group=>{
    const row=document.createElement('div'); row.className='anim-group';
    const nameBadge=document.createElement('span'); nameBadge.className='anim-group-name'; nameBadge.textContent=group.name; row.appendChild(nameBadge);
    if(group.morphNames.length>1){
      const sel=document.createElement('select');
      group.morphNames.forEach(n=>{ const o=document.createElement('option'); o.value=n;o.textContent=n; sel.appendChild(o); });
      sel.onchange=()=>{ group.activeMorph=sel.value; const m0=group.meshes.find(m=>m.morphTargetDictionary && group.activeMorph in m.morphTargetDictionary);
        if(m0){ const i=m0.morphTargetDictionary[group.activeMorph]; const v=m0.morphTargetInfluences[i]??0; slider.value=String(v); }
      };
      row.appendChild(sel); group.selectEl=sel;
    }
    const slider=document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='1'; slider.step='0.01'; slider.value='0'; slider.className='anim-slider';
    slider.oninput=()=>{ const val=parseFloat(slider.value);
      group.meshes.forEach(m=>{ const d=m.morphTargetDictionary, inf=m.morphTargetInfluences; if(!d||!inf) return; if(group.activeMorph in d){ inf[d[group.activeMorph]]=val; m.needsUpdate=true; }});
      updateMeasureOverlay();
    };
    row.appendChild(slider); group.sliderEl=slider; inner.appendChild(row);
    const m0=group.meshes.find(m=>m.morphTargetDictionary && group.activeMorph in m.morphTargetDictionary);
    if(m0){ const i=m0.morphTargetDictionary[group.activeMorph]; const v=m0.morphTargetInfluences[i]??0; slider.value=String(v); }
    if(group.selectEl){ group.selectEl.value=group.activeMorph; }
  });
  side.appendChild(wrap);
}
function setupAssetControlsMulti(rootScene){
  assetRoot = null;
  rootScene.traverse(o=>{ if(!assetRoot && o.name && /^model_/i.test(o.name)) assetRoot = o; });
  if(!assetRoot){
    removeAssetUI(); setUIMode('room'); clearMeasureOverlay(); removeShadowSystem(); return;
  }
  setUIMode('asset');

  const animRoots = findAnimRoots(assetRoot);
  const groups = [];
  animRoots.forEach(ar=>{
    const meshes = collectMorphMeshes(ar); if(!meshes.length) return;
    const morphNames = uniqueNamesFromMeshes(meshes); if(!morphNames.length) return;
    groups.push({ name: ar.name, meshes, morphNames, activeMorph: morphNames[0], selectEl:null, sliderEl:null });
  });
  animGroups = groups;
  if(animGroups.length) buildAnimUI();

  updateMeasureOverlay();
  ensureShadowSystem();
}

/* ---------- Measurement overlay (SVG) ---------- */
const svg = document.getElementById('measureOverlay');
const svgNS = 'http://www.w3.org/2000/svg';
const defs = document.createElementNS(svgNS,'defs');
const marker = document.createElementNS(svgNS,'marker');
marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','6'); marker.setAttribute('markerHeight','6');
marker.setAttribute('refX','6'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
const arrowPath = document.createElementNS(svgNS,'path'); arrowPath.setAttribute('d','M0,0 L6,3 L0,6 Z'); arrowPath.setAttribute('fill','#2b60ff');
marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);

function clearMeasureOverlay(){ while(svg.childNodes.length>1) svg.removeChild(svg.lastChild); }
function projectToScreen(v3){
  const v = v3.clone().project(camera);
  return { x:(v.x*0.5+0.5)*innerWidth, y:(-v.y*0.5+0.5)*innerHeight, z:v.z, ok:(v.z>-1 && v.z<1) };
}
function labelBadge(x,y,text){
  const padX=10, padY=6;
  const textEl = document.createElementNS(svgNS,'text'); textEl.setAttribute('class','m-text'); textEl.setAttribute('x',x); textEl.setAttribute('y',y); textEl.textContent = text;
  svg.appendChild(textEl); const bb = textEl.getBBox(); svg.removeChild(textEl);
  const bg = document.createElementNS(svgNS,'rect'); bg.setAttribute('class','m-badge');
  bg.setAttribute('x', bb.x - padX); bg.setAttribute('y', bb.y - padY); bg.setAttribute('rx', 12); bg.setAttribute('ry', 12);
  bg.setAttribute('width', bb.width + padX*2); bg.setAttribute('height', bb.height + padY*2);
  svg.appendChild(bg); svg.appendChild(textEl);
}
function drawDim(x1,y1,x2,y2,label){
  const line = document.createElementNS(svgNS,'line'); line.setAttribute('class','m-line'); line.setAttribute('x1',x1); line.setAttribute('y1',y1); line.setAttribute('x2',x2); line.setAttribute('y2',y2);
  const a1 = document.createElementNS(svgNS,'line'); a1.setAttribute('class','m-arrow'); a1.setAttribute('x1',x1); a1.setAttribute('y1',y1); a1.setAttribute('x2',x2); a1.setAttribute('y2',y2);
  svg.appendChild(line); svg.appendChild(a1);
  const cx = (x1+x2)/2, cy = (y1+y2)/2; labelBadge(cx, cy - 14, label);
}
function updateMeasureOverlay(){
  // respetar toggle
  if(!assetRoot) return;
  if(dimsToggle && !dimsToggle.checked) return;

  clearMeasureOverlay();
  const box = new THREE.Box3().setFromObject(assetRoot);
  const ctr = box.getCenter(new THREE.Vector3());
  const sz  = box.getSize(new THREE.Vector3());

  const frontZ = (camera.position.z >= ctr.z) ? box.max.z : box.min.z;
  const leftX  = (camera.position.x >= ctr.x) ? box.min.x : box.max.x;
  const rightX = (leftX===box.min.x) ? box.max.x : box.min.x;

  const topY = box.max.y, botY = box.min.y;
  const topL = new THREE.Vector3(leftX,  topY, frontZ);
  const topR = new THREE.Vector3(rightX, topY, frontZ);
  const botL = new THREE.Vector3(leftX,  botY, frontZ);
  const back = (frontZ===box.max.z) ? box.min.z : box.max.z;
  const botLBack = new THREE.Vector3(leftX, botY, back);

  const off = 18; // px de separación del objeto
  const p = v => projectToScreen(v);
  const tL = p(topL), tR = p(topR), bL = p(botL), bLB = p(botLBack);

  const cm = v => `${Math.round(v*100)} cm`;
  if(tL.ok && tR.ok) drawDim(tL.x, tL.y - off, tR.x, tR.y - off, cm(sz.x)); // ancho
  if(bL.ok && tL.ok) drawDim(bL.x - off, bL.y, tL.x - off, tL.y, cm(sz.y)); // alto
  if(bL.ok && bLB.ok) drawDim(bL.x, bL.y + off, bLB.x, bLB.y + off, cm(sz.z)); // profundo
}

/* ---------- Sombras suaves (shadow catcher) ---------- */
function setCastShadow(obj, val){
  obj.traverse(o=>{ if(o.isMesh){ o.castShadow = !!val; }});
}
function ensureShadowSystem(){
  if(!assetRoot) return;

  if(!dirLight){
    dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(1024,1024);
    dirLight.shadow.bias = -0.0001;
    dirLight.shadow.normalBias = 0.02;
    scene.add(dirLight);
  }
  if(!shadowPlane){
    const mat = new THREE.ShadowMaterial({ opacity: 0.12 });
    const geo = new THREE.PlaneGeometry(1,1);
    shadowPlane = new THREE.Mesh(geo, mat);
    shadowPlane.rotation.x = -Math.PI/2;
    shadowPlane.receiveShadow = true;
    shadowPlane.renderOrder = -1;
    scene.add(shadowPlane);
  }

  const box = new THREE.Box3().setFromObject(assetRoot);
  const size= box.getSize(new THREE.Vector3());
  const ctr = box.getCenter(new THREE.Vector3());

  shadowPlane.position.set(ctr.x, box.min.y + 0.0001, ctr.z);
  shadowPlane.scale.set(size.x*1.05, size.z*1.05, 1);

  // casi cenital; apenas desfasada para “dirección” de sombra
  dirLight.position.set(ctr.x + size.x*0.05, box.max.y + size.y*2.0, ctr.z + size.z*0.05);
  dirLight.target.position.set(ctr.x, ctr.y, ctr.z);
  scene.add(dirLight.target);

  setCastShadow(assetRoot, true);
}
function removeShadowSystem(){
  if(shadowPlane){
    shadowPlane.geometry.dispose(); shadowPlane.material.dispose();
    scene.remove(shadowPlane); shadowPlane=null;
  }
  if(dirLight){
    scene.remove(dirLight.target);
    scene.remove(dirLight);
    dirLight = null;
  }
}

/* ---------- placing ---------- */
function place(root){
  root.traverse(o=>{
    if(o.isMesh && /collider/i.test(o.name)) o.visible=false;
    if(o.isMesh && /^ceiling\d*$/i.test(o.name)) o.visible=false;
  });

  new THREE.Box3().setFromObject(root).getCenter(root.position).multiplyScalar(-1);
  const box  = new THREE.Box3().setFromObject(root);
  const size = box.getSize(new THREE.Vector3());
  root.position.y -= box.min.y;

  allNodes = []; root.traverse(o=>{ if(o.name) allNodes.push(o); });
  ceilings  = allNodes.filter(o => /^ceiling\d*$/i.test(o.name));
  wallRoots = allNodes.filter(o => /^wall\d+$/i.test(o.name));

  doorPanels       = findDoorPanels(allNodes);
  doorVariantPairs = findDoorVariantPairs(allNodes);
  enforceDoorVariantExclusivity('closed');
  reparentHardwareToDoors(allNodes, doorPanels);

  current = root; scene.add(root);

  // detectar cualquier model_
  assetRoot = null;
  current.traverse(o=>{ if(!assetRoot && o.name && /^model_/i.test(o.name)) assetRoot = o; });

  setUIMode(assetRoot ? 'asset' : 'room');
  if(assetRoot){
    setupAssetControlsMulti(current);
    ensureShadowSystem();
    updateMeasureOverlay();
  }else{
    removeAssetUI(); clearMeasureOverlay(); removeShadowSystem();
  }

  const maxDim = Math.max(size.x,size.y,size.z);
  camera.position.setScalar(maxDim*1.6).setY(maxDim*0.8);
  controls.target.copy(new THREE.Box3().setFromObject(root).getCenter(new THREE.Vector3()));
  controls.update();

  updateStats(size);
}

/* ---------- doors actions ---------- */
function setDoorRotation(o, open){
  const amt = open ? 1 : 0;
  const rad = THREE.MathUtils.degToRad(90 * o.userData.sign * THREE.MathUtils.clamp(amt,0,1));
  o.quaternion.copy(o.userData.closedQ); o.rotateY(rad);
}
function toggleDoors(open){
  doorPanels.forEach(o=> setDoorRotation(o, open));
  doorVariantPairs.forEach(pair=>{
    const {open:openNode, closed:closedNode} = pair;
    if(openNode)  openNode.visible  = !!open;
    if(closedNode)closedNode.visible= !open;
  });
  if(allNodes?.length){
    const hardware = allNodes.filter(o => /(handle|hinge|knob|hardware)/i.test(o.name));
    hardware.forEach(h=>{
      const idx=extractIndex(h.name), sidePref=extractSide(h.name), groupKeyPref=doorGroupKey(h.name);
      if(idx==null) return;
      const target = pickPreferredDoorRoot(idx, sidePref, groupKeyPref);
      if(target && h.parent !== target) reparentKeepWorld(h, target);
    });
  }
}

/* ---------- auto-hide wall (rooms) ---------- */
const ray = new THREE.Raycaster();
function wallRootOf(obj){ let p=obj; while(p){ if(/^wall\d+$/i.test(p.name)) return p; p=p.parent; } return null; }
function sampleFrontWalls(){
  if(!wallRoots?.length) return new Set();
  let closest=null, closestDist=Infinity;
  const distToTarget = camera.position.distanceTo(controls.target);
  const samples=[{x:0,y:0},{x:0.14,y:0},{x:-0.14,y:0},{x:0,y:0.14},{x:0,y:-0.14}];
  for(const ndc of samples){
    ray.setFromCamera(ndc, camera);
    const hits = ray.intersectObjects(wallRoots, true);
    if(hits.length){
      const h = hits[0];
      if(h.distance < distToTarget*0.995 && h.distance < closestDist){
        closest = wallRootOf(h.object); closestDist = h.distance;
      }
    }
  }
  return closest ? new Set([closest]) : new Set();
}
function updateAutoHide(){
  const autoHToggle=document.getElementById('autoHideToggle');
  if(!autoHToggle || autoHToggle.closest('label').style.display==='none') return;
  if(!autoHToggle.checked || !current) return;
  const front = sampleFrontWalls();
  for(const wr of Array.from(lastHiddenWalls)){ if(!front.has(wr)){ wr.visible=true; lastHiddenWalls.delete(wr);} }
  for(const wr of front){ if(!lastHiddenWalls.has(wr)){ wr.visible=false; lastHiddenWalls.add(wr);} }
}

/* ---------- loading ---------- */
function loadFromURL(url){
  setUIMode('clean'); setMsg('Loading…'); clearModel();
  try{ const fname=url.split('/').pop()?.split('?')[0]; const pre=guessModeFromFilename(fname); if(pre) setUIMode(pre);}catch{}
  loader.load(url, g=>{ place(g.scene); setMsg('Loaded'); },
    xhr=>{ if(xhr.total) setMsg(`Loading ${(xhr.loaded/xhr.total*100).toFixed(0)}%`); },
    err=>{ console.error(err); setMsg('Error loading model'); });
}
function loadBlob(file){
  setUIMode('clean'); setMsg('Loading local file…'); clearModel();
  const pre=guessModeFromFilename(file.name); if(pre) setUIMode(pre);
  const url = URL.createObjectURL(file);
  loader.load(url, g=>{ place(g.scene); setMsg(file.name); URL.revokeObjectURL(url); },
    undefined, e=>{ console.error(e); setMsg('Error with local file'); });
}

/* ---------- UI ---------- */
const urlInput = document.getElementById('url');
document.getElementById('loadBtn').onclick = ()=>{ const u=urlInput.value.trim(); if(u) loadFromURL(u); };
const fileInput = document.getElementById('fileInput');
document.getElementById('fileBtn').onclick = ()=>{ fileInput.value=''; fileInput.click(); };
fileInput.onchange = ()=>{ const f=fileInput.files?.[0]; if(f) loadBlob(f); };
document.getElementById('doorsToggle').onchange = e=> toggleDoors(e.target.checked);
document.getElementById('hideCeilingToggle').onchange = e=>{ ceilings.forEach(c=> c.visible = !e.target.checked); };

/* ---------- drag & drop ---------- */
const drop=document.getElementById('drop');
['dragenter','dragover','dragleave','drop'].forEach(ev=>{
  window.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); }, false);
});
window.addEventListener('dragenter', ()=> drop.style.display='flex');
window.addEventListener('dragover',  ()=> drop.style.display='flex');
window.addEventListener('dragleave', e=>{
  if(e.clientX<=0||e.clientY<=0||e.clientX>=innerWidth||e.clientY>=innerHeight){ drop.style.display='none'; }
});
function handleDrop(e){
  e.preventDefault(); e.stopPropagation();
  drop.style.display='none';
  const f=e.dataTransfer?.files?.[0]; if(f) loadBlob(f);
}
drop.addEventListener('drop', handleDrop);

/* ---------- ?model= ---------- */
const modelURL=new URLSearchParams(location.search).get('model');
if(modelURL){ urlInput.value=modelURL; loadFromURL(modelURL); }

/* ---------- resize & loop ---------- */
function resize(){
  const w=innerWidth,h=innerHeight;
  renderer.setSize(w,h,false);
  camera.aspect=w/h; camera.updateProjectionMatrix();
}
addEventListener('resize', ()=>{ resize(); updateMeasureOverlay(); ensureShadowSystem(); });
resize();

renderer.setAnimationLoop(()=>{
  controls.update();
  updateAutoHide();
  updateMeasureOverlay();
  ensureShadowSystem();
  renderer.render(scene,camera);
});
</script>
</body>
</html>
