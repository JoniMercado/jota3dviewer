<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Room Viewer — v0.0.2</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.164/examples/jsm/"
  }
}
</script>

<style>
  html,body{height:100%;margin:0}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;background:#c9c9c9;color:#222}

  /* Header fijo y compacto */
  #topbar{
    position:fixed;inset:12px auto auto 12px;
    display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    background:rgba(255,255,255,.85);backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08);border-radius:12px;
    padding:10px 12px;z-index:10;max-width:min(900px, calc(100% - 312px));
  }
  #topbar input,#topbar select{background:#f5f5f5;border:1px solid #ccc;color:#111;border-radius:6px;padding:6px 8px}
  #topbar button{background:#1e68ff;border:none;color:white;padding:6px 10px;border-radius:6px;cursor:pointer}
  #topbar small{opacity:.7}
  #fileInput{display:none}

  /* Panel lateral derecho (animaciones y más) */
  #sidepanel{
    position:fixed;right:12px;top:12px;
    width:280px;max-height:calc(100% - 24px);overflow:auto;
    display:flex;flex-direction:column;gap:8px;
    z-index:9; /* debajo del header (10) para que no lo tape al abrir combos del header */
  }
  .card{
    background:rgba(255,255,255,.9);backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08);border-radius:12px;padding:10px 12px;
  }
  details.asset-anim{border:1px solid rgba(0,0,0,.08);border-radius:10px;background:#fff}
  details.asset-anim > summary{
    list-style:none;cursor:pointer;padding:8px 10px;border-radius:10px;
    background:#f9f9f9;border:1px solid rgba(0,0,0,.06);
    font-weight:600;font-size:14px;
  }
  details.asset-anim[open] > summary{background:#f3f6ff;border-color:#ccd9ff}
  .anim-panel{padding:8px 10px}
  .anim-group{display:flex;align-items:center;gap:8px;margin-top:8px;flex-wrap:wrap}
  .anim-group-name{font-size:12px;opacity:.8;padding:2px 6px;background:#f2f2f2;border-radius:6px}
  .anim-slider{width:160px}
  .muted{opacity:.7;font-size:12px}

  #stats{
    position:fixed;inset:auto 12px 12px 12px;
    background:rgba(255,255,255,.85);border:1px solid rgba(0,0,0,.08);
    border-radius:12px;padding:8px 12px;display:flex;gap:16px;flex-wrap:wrap
  }
  #drop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;border:2px dashed #2a2f36;border-radius:16px;background:rgba(30,104,255,.08);color:#1e68ff;pointer-events:auto}
  canvas{display:block;width:100%;height:100%}
  label{display:flex;align-items:center;gap:6px}

  /* Responsive: si la pantalla es estrecha, que el sidepanel se achique y no tape el header */
  @media (max-width: 960px){
    #topbar{max-width:calc(100% - 24px)}
    #sidepanel{width:240px}
  }
</style>
</head>
<body>
  <div id="topbar">
    <small>GLB URL</small>
    <input id="url" placeholder="https://example.com/model.glb" />
    <button id="loadBtn">Load</button>
    <button id="fileBtn">Open .glb</button>
    <input type="file" id="fileInput" accept=".glb,model/gltf-binary" />

    <label><input type="checkbox" id="doorsToggle"> All Doors Open</label>
    <label><input type="checkbox" id="autoHideToggle" checked> Auto-hide front wall</label>
    <label><input type="checkbox" id="hideCeilingToggle" checked> Hide ceiling</label>

    <label>HDR
      <select id="hdrSelect">
        <option value="">Room (default)</option>
        <option value="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr">Studio Small</option>
        <option value="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/neutral_wall_1k.hdr">Neutral Grey</option>
      </select>
    </label>
    <small id="msg"></small>
  </div>

  <!-- Panel lateral derecho (aquí van animaciones y futuros módulos) -->
  <div id="sidepanel">
    <!-- Ejemplo: podríamos colocar otras tarjetas acá en el futuro -->
  </div>

  <div id="stats"></div>
  <div id="drop">Drop a .glb file to view</div>
  <canvas id="c"></canvas>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

/* ---------- renderer / scene / camera ---------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(devicePixelRatio,2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xc9c9c9);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(2,1.2,2);

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,0.6,0);
controls.enableDamping = true;

/* iluminación integral */
scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.0));
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

/* ---------- loaders ---------- */
const draco  = new DRACOLoader().setDecoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/draco/');
const ktx2   = new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/basis/').detectSupport(renderer);
const loader = new GLTFLoader().setDRACOLoader(draco).setKTX2Loader(ktx2);

/* ---------- state ---------- */
let current = null;
let allNodes = [], doorPanels = [], doorVariantPairs = [], ceilings = [], wallRoots = [];
let lastHiddenWalls = new Set(); // auto-hide
let lastGLBBytes = null;         // peso del GLB
const MAX_DOOR_DEG = 90;

// Asset detection + anim UI (multi-grupo en sidepanel)
let assetRoot = null;
let isAsset   = false;
let uiAssetWrap = null; // <details> que contiene todo el panel de anim
let animGroups = [];    // [{name, meshes, morphNames, activeMorph, selectEl, sliderEl}]

/* ---------- utils ---------- */
function setMsg(t){ document.getElementById('msg').textContent = t || ''; }
function humanBytes(b){
  if(b==null) return '—';
  const u=['B','KB','MB','GB']; let i=0; let n=b;
  while(n>=1024 && i<u.length-1){ n/=1024; i++; }
  return `${n.toFixed(n<10&&i>0?1:0)} ${u[i]}`;
}
function disposeMat(m){ ['map','normalMap','roughnessMap','metalnessMap','occlusionMap','emissiveMap'].forEach(k=>m[k]?.dispose?.()); }
function clearModel(){
  if(!current) return;
  scene.remove(current);
  current.traverse?.(o=>{
    if(o.geometry) o.geometry.dispose();
    const m=o.material;
    if(m) (Array.isArray(m)?m:[m]).forEach(disposeMat);
  });
  current=null; allNodes=[]; doorPanels=[]; doorVariantPairs=[]; ceilings=[]; wallRoots=[]; lastHiddenWalls.clear();
  removeAssetUI(); // limpiar UI de anim si existía
}
function triCount(obj){ let t=0; obj.traverse(o=>{ if(o.isMesh){ const g=o.geometry; t += g?.index ? g.index.count/3 : (g?.attributes?.position?.count||0)/3; }}); return Math.round(t); }
function updateStats(sizeVec){
  const tris = current ? triCount(current).toLocaleString() : '—';
  const sz   = sizeVec ? `${sizeVec.x.toFixed(2)} × ${sizeVec.y.toFixed(2)} × ${sizeVec.z.toFixed(2)} m` : '—';
  document.getElementById('stats').textContent = `Tris: ${tris} | Size: ${sz} | GLB: ${humanBytes(lastGLBBytes)}`;
}

/* ---------- parenting & naming helpers ---------- */
function reparentKeepWorld(child, newParent){
  child.updateMatrixWorld(true);
  const childWorld = child.matrixWorld.clone();
  newParent.updateMatrixWorld(true);
  newParent.add(child);
  const invParentWorld = newParent.matrixWorld.clone().invert();
  const local = new THREE.Matrix4().multiplyMatrices(invParentWorld, childWorld);
  local.decompose(child.position, child.quaternion, child.scale);
  child.updateMatrixWorld(true);
}
function extractIndex(name){
  if(!name) return null;
  let match = name.match(/door(\d+)/i);
  if(match) return match[1];
  match = name.match(/panel(\d+)/i);
  if(match) return match[1];
  match = name.match(/(\d+)(?!.*\d)/);
  return match ? match[1] : null;
}
function extractSide(name){
  if(!name) return null;
  if(/leftpanel/i.test(name) || /_left/i.test(name)) return 'left';
  if(/rightpanel/i.test(name) || /_right/i.test(name)) return 'right';
  return null;
}
/* Diferenciador de “grupo” para puertas que comparten idx/side pero pertenecen a conjuntos distintos */
function doorGroupKey(name){
  if(!name) return '';
  const m = name.match(/^(.*?_door\d+)/i); // hasta "..._doorN"
  if(m) return m[1].toLowerCase();
  const m2 = name.match(/^(.*?)(?:_(?:open|closed))?(?:leftpanel|rightpanel)\d+/i);
  if(m2) return m2[1].toLowerCase();
  return name.toLowerCase();
}

/* ---------- UI Anim (shape keys) multi-grupo en sidepanel ---------- */
function removeAssetUI(){
  animGroups = [];
  assetRoot  = null;
  isAsset    = false;
  if(uiAssetWrap){
    uiAssetWrap.remove();
    uiAssetWrap = null;
  }
}
function collectMorphMeshes(root){
  const out = [];
  root.traverse(o=>{
    if(o.isMesh && o.morphTargetInfluences && o.morphTargetDictionary){
      out.push(o);
    }
  });
  return out;
}
function uniqueNamesFromMeshes(meshes){
  const set = new Set();
  meshes.forEach(m=>{
    const dict = m.morphTargetDictionary;
    if(!dict) return;
    Object.keys(dict).forEach(k=> set.add(k));
  });
  return Array.from(set);
}
// Encuentra nodos de animación válidos:
// - Prefijo recomendado: "anim_*"
// - Compatibilidad: "cajon_anim", "cajon_anim_1", "cajon_anim_2", etc.
function findAnimRoots(asset){
  const animRoots = [];
  asset.traverse(o=>{
    if(!o.name) return;
    const name = o.name.toLowerCase();
    if(/^anim_/.test(name) || /^cajon_anim/.test(name)){
      animRoots.push(o);
    }
  });
  return animRoots.filter(o=> o !== asset);
}
function buildAnimUI(){
  const side = document.getElementById('sidepanel');
  // contenedor plegable único para Anim
  uiAssetWrap = document.createElement('details');
  uiAssetWrap.className = 'asset-anim card';
  uiAssetWrap.open = true;

  const summary = document.createElement('summary');
  summary.textContent = 'Anim';
  uiAssetWrap.appendChild(summary);

  const inner = document.createElement('div');
  inner.className = 'anim-panel';
  uiAssetWrap.appendChild(inner);

  // info ligera
  const info = document.createElement('div');
  info.className = 'muted';
  info.textContent = 'Control de shape keys por grupo (prefijo anim_)';
  inner.appendChild(info);

  // grupos
  animGroups.forEach(group=>{
    const row = document.createElement('div');
    row.className = 'anim-group';

    const nameBadge = document.createElement('span');
    nameBadge.className = 'anim-group-name';
    nameBadge.textContent = group.name;
    row.appendChild(nameBadge);

    // si hay >1 morph, selector
    if(group.morphNames.length > 1){
      const sel = document.createElement('select');
      group.morphNames.forEach(n=>{
        const opt = document.createElement('option');
        opt.value = n; opt.textContent = n;
        sel.appendChild(opt);
      });
      sel.onchange = ()=>{
        group.activeMorph = sel.value;
        // poner el slider al valor actual del primer mesh que tenga ese morph
        const m0 = group.meshes.find(m=>m.morphTargetDictionary && group.activeMorph in m.morphTargetDictionary);
        if(m0){
          const i = m0.morphTargetDictionary[group.activeMorph];
          const v = m0.morphTargetInfluences[i] ?? 0;
          slider.value = String(v);
        }
      };
      row.appendChild(sel);
      group.selectEl = sel;
    }

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = '0';
    slider.max = '1';
    slider.step = '0.01';
    slider.value = '0';
    slider.className = 'anim-slider';
    slider.oninput = ()=>{
      const val = parseFloat(slider.value);
      group.meshes.forEach(m=>{
        const dict = m.morphTargetDictionary;
        const infl = m.morphTargetInfluences;
        if(!dict || !infl) return;
        if(group.activeMorph in dict){
          infl[dict[group.activeMorph]] = val;
          m.needsUpdate = true;
        }
      });
    };
    row.appendChild(slider);
    group.sliderEl = slider;

    inner.appendChild(row);

    // estado inicial de slider/selector
    const m0 = group.meshes.find(m=>m.morphTargetDictionary && group.activeMorph in m.morphTargetDictionary);
    if(m0){
      const i = m0.morphTargetDictionary[group.activeMorph];
      const v = m0.morphTargetInfluences[i] ?? 0;
      slider.value = String(v);
    }
    if(group.selectEl){
      group.selectEl.value = group.activeMorph;
    }
  });

  side.appendChild(uiAssetWrap);
}
function setupAssetControlsMulti(rootScene){
  // Buscar hijo cuyo nombre empiece por model_
  assetRoot = rootScene.children.find(c => /^model_/i.test(c.name));
  isAsset = !!assetRoot;
  if(!isAsset){ removeAssetUI(); return; }

  // Encontrar todos los nodos anim_* (y cajon_anim*) dentro del asset
  const animRoots = findAnimRoots(assetRoot);
  const groups = [];

  animRoots.forEach(ar=>{
    const meshes = collectMorphMeshes(ar);
    if(!meshes.length) return; // sin morphs: ignorar

    const morphNames = uniqueNamesFromMeshes(meshes);
    if(!morphNames.length) return;

    groups.push({
      name: ar.name,
      meshes,
      morphNames,
      activeMorph: morphNames[0],
      selectEl: null,
      sliderEl: null,
    });
  });

  if(!groups.length){ removeAssetUI(); return; }

  animGroups = groups;
  buildAnimUI();
}

/* ---------- puertas ---------- */
// Rotatorias: leftpanelX / rightpanelX (sin sufijo open/closed)
// Variantes: *_closedleftpanelX y *_openleftpanelX (y rightpanel)
function findDoorPanels(nodes){
  const panels = nodes.filter(o => /(leftpanel|rightpanel)\d+$/i.test(o.name) && !/_open|_closed/i.test(o.name));
  return panels.map(o=>{
    const left = /leftpanel/i.test(o.name);
    o.userData.closedQ  = o.quaternion.clone();
    o.userData.sign     = left ? +1 : -1; // +Y izq, -Y der
    o.userData.groupKey = doorGroupKey(o.name);
    o.userData.idx      = extractIndex(o.name);
    o.userData.side     = left ? 'left' : 'right';
    return o;
  });
}
function findDoorVariantPairs(nodes){
  const map = new Map(); // key = groupKey|side|idx
  nodes.forEach(o=>{
    const m = o.name.match(/_(open|closed)(leftpanel|rightpanel)(\d+)$/i);
    if(!m) return;
    const state = m[1].toLowerCase();
    const side  = m[2].toLowerCase();
    const idx   = m[3];
    const group = doorGroupKey(o.name);
    const key   = `${group}|${side}|${idx}`;
    if(!map.has(key)) map.set(key, { open:null, closed:null, group, side, idx });
    map.get(key)[state] = o;
  });
  return Array.from(map.values()).filter(p => p.open || p.closed);
}
function enforceDoorVariantExclusivity(defaultOpen){
  const openFlag = (defaultOpen != null)
    ? !!defaultOpen
    : !!document.getElementById('doorsToggle')?.checked;
  doorVariantPairs.forEach(({open, closed})=>{
    if(open && closed){
      open.visible   = openFlag;
      closed.visible = !openFlag;
    } else if(open){
      open.visible   = openFlag;
    } else if(closed){
      closed.visible = !openFlag;
    }
  });
}
function getDoorRootsByIndex(groupKeyPref, idx, sidePref){
  const roots = [];

  // paneles rotatorios
  doorPanels.forEach(d=>{
    const di   = d.userData.idx ?? extractIndex(d.name);
    const side = d.userData.side ?? extractSide(d.name);
    const gk   = d.userData.groupKey ?? doorGroupKey(d.name);
    if(String(di) === String(idx)
      && (!sidePref || sidePref===side)
      && (!groupKeyPref || groupKeyPref===gk)) {
      roots.push(d);
    }
  });

  // variantes open/closed
  doorVariantPairs.forEach(pair=>{
    const { open, closed, group, side, idx:pi } = pair;
    [open, closed].filter(Boolean).forEach(n=>{
      const di = pi ?? extractIndex(n.name);
      const gk = group ?? doorGroupKey(n.name);
      const sd = side  ?? extractSide(n.name);
      if(String(di) === String(idx)
        && (!sidePref || sidePref===sd)
        && (!groupKeyPref || groupKeyPref===gk)) {
        roots.push(n);
      }
    });
  });

  return roots;
}
function pickPreferredDoorRoot(idx, sidePref, groupKeyPref){
  const roots = getDoorRootsByIndex(groupKeyPref, idx, sidePref);
  if(!roots.length){
    const anyGroup = getDoorRootsByIndex(null, idx, sidePref);
    if(anyGroup.length) return anyGroup.find(r=>r.visible===true) || anyGroup[0];
    const anySideAnyGroup = getDoorRootsByIndex(null, idx, null);
    if(anySideAnyGroup.length) return anySideAnyGroup.find(r=>r.visible===true) || anySideAnyGroup[0];
    return null;
  }
  return roots.find(r=>r.visible===true) || roots[0];
}
function reparentHardwareToDoors(nodes, _doorPanels){
  const hardware = nodes.filter(o => /(handle|hinge|knob|hardware)/i.test(o.name));
  hardware.forEach(h=>{
    const idx          = extractIndex(h.name);
    const sidePref     = extractSide(h.name);
    const groupKeyPref = doorGroupKey(h.name);

    let target = (idx!=null) ? pickPreferredDoorRoot(idx, sidePref, groupKeyPref) : null;

    if(!target){
      // fallback por cercanía dentro del mismo groupKey si es posible
      let candidates = _doorPanels;
      const sameGroup = _doorPanels.filter(d => (d.userData.groupKey ?? doorGroupKey(d.name)) === groupKeyPref);
      if(sameGroup.length) candidates = sameGroup;
      if(sidePref){
        const filtered = candidates.filter(d=> (d.userData.side ?? extractSide(d.name))===sidePref);
        if(filtered.length) candidates = filtered;
      }
      let best=null, bestDist=Infinity;
      const hp = new THREE.Vector3(); new THREE.Box3().setFromObject(h).getCenter(hp);
      candidates.forEach(d=>{
        const dp = new THREE.Vector3(); new THREE.Box3().setFromObject(d).getCenter(dp);
        const dist = hp.distanceTo(dp);
        if(dist<bestDist){ bestDist=dist; best=d; }
      });
      target = best;
    }

    if(target && h.parent !== target) reparentKeepWorld(h, target);
  });
}

/* ---------- placing ---------- */
function place(root){
  // Ocultar colliders y techo por defecto
  root.traverse(o=>{
    if(o.isMesh && /collider/i.test(o.name)) o.visible=false;
    if(o.isMesh && /^ceiling\d*$/i.test(o.name)) o.visible=false;
  });

  // centrar / apoyar
  new THREE.Box3().setFromObject(root).getCenter(root.position).multiplyScalar(-1);
  const box  = new THREE.Box3().setFromObject(root);
  const size = box.getSize(new THREE.Vector3());
  root.position.y -= box.min.y;

  // recolectar
  allNodes = []; root.traverse(o=>{ if(o.name) allNodes.push(o); });
  ceilings  = allNodes.filter(o => /^ceiling\d*$/i.test(o.name));
  wallRoots = allNodes.filter(o => /^wall\d+$/i.test(o.name));

  // puertas rotatorias & variantes
  doorPanels       = findDoorPanels(allNodes);
  doorVariantPairs = findDoorVariantPairs(allNodes);

  // asegurar exclusividad de variantes y luego emparentar herrajes
  enforceDoorVariantExclusivity();
  reparentHardwareToDoors(allNodes, doorPanels);

  current = root; scene.add(root);

  // detectar activo 'model_*' y preparar UI/controles de morph para múltiples grupos (anim_*)
  setupAssetControlsMulti(current);

  // cámara + stats
  const maxDim = Math.max(size.x,size.y,size.z);
  camera.position.setScalar(maxDim*1.6).setY(maxDim*0.8);
  controls.target.copy(new THREE.Box3().setFromObject(root).getCenter(new THREE.Vector3()));
  controls.update();

  updateStats(size);
}

/* ---------- doors actions ---------- */
function setDoorRotation(o, open){
  const amt = open ? 1 : 0;
  const rad = THREE.MathUtils.degToRad(MAX_DOOR_DEG * o.userData.sign * THREE.MathUtils.clamp(amt,0,1));
  o.quaternion.copy(o.userData.closedQ);
  o.rotateY(rad);
}
function toggleDoors(open){
  // Rotatorias
  doorPanels.forEach(o=> setDoorRotation(o, open));

  // Variantes
  doorVariantPairs.forEach(pair=>{
    const {open:openNode, closed:closedNode} = pair;
    if(openNode)  openNode.visible  = !!open;
    if(closedNode)closedNode.visible= !open;
  });

  // Reubicar herrajes post-cambio (respetando groupKey + side + idx)
  if(allNodes?.length){
    const hardware = allNodes.filter(o => /(handle|hinge|knob|hardware)/i.test(o.name));
    hardware.forEach(h=>{
      const idx          = extractIndex(h.name);
      const sidePref     = extractSide(h.name);
      const groupKeyPref = doorGroupKey(h.name);
      if(idx==null) return;
      const target = pickPreferredDoorRoot(idx, sidePref, groupKeyPref);
      if(target && h.parent !== target) reparentKeepWorld(h, target);
    });
  }
}

/* ---------- auto-hide wall (solo la más cercana) ---------- */
const ray = new THREE.Raycaster();
function wallRootOf(obj){ let p=obj; while(p){ if(/^wall\d+$/i.test(p.name)) return p; p=p.parent; } return null; }
function sampleFrontWalls(){
  if(!wallRoots?.length) return new Set();
  let closest = null;
  let closestDist = Infinity;
  const distToTarget = camera.position.distanceTo(controls.target);
  const samples = [ {x:0,y:0},{x:0.14,y:0},{x:-0.14,y:0},{x:0,y:0.14},{x:0,y:-0.14} ];
  for(const ndc of samples){
    ray.setFromCamera(ndc, camera);
    const hits = ray.intersectObjects(wallRoots, true);
    if(hits.length){
      const h = hits[0];
      if(h.distance < distToTarget*0.995 && h.distance < closestDist){
        closest = wallRootOf(h.object);
        closestDist = h.distance;
      }
    }
  }
  return closest ? new Set([closest]) : new Set();
}
function updateAutoHide(){
  if(!document.getElementById('autoHideToggle').checked || !current) return;
  const front = sampleFrontWalls();
  for(const wr of Array.from(lastHiddenWalls)){
    if(!front.has(wr)){ wr.visible = true; lastHiddenWalls.delete(wr); }
  }
  for(const wr of front){
    if(!lastHiddenWalls.has(wr)){ wr.visible = false; lastHiddenWalls.add(wr); }
  }
}

/* ---------- loading ---------- */
async function headSize(url){
  try{
    const r = await fetch(url, { method:'HEAD', mode:'cors' });
    const v = r.headers.get('content-length');
    return v ? parseInt(v) : null;
  }catch{ return null; }
}
function loadFromURL(url){
  setMsg('Loading…'); clearModel(); lastGLBBytes = null;
  headSize(url).then(sz => { if(sz) { lastGLBBytes = sz; updateStats(); } });
  loader.load(url, g=>{ place(g.scene); setMsg('Loaded'); },
    xhr=>{ if(xhr.total){ lastGLBBytes = xhr.total; updateStats(); setMsg(`Loading ${(xhr.loaded/xhr.total*100).toFixed(0)}%`);} },
    err=>{ console.error(err); setMsg('Error loading model'); });
}
function loadBlob(file){
  setMsg('Loading local file…'); clearModel();
  lastGLBBytes = file.size; updateStats();
  const url = URL.createObjectURL(file);
  loader.load(url, g=>{ place(g.scene); setMsg(file.name); URL.revokeObjectURL(url); },
    undefined, e=>{ console.error(e); setMsg('Error with local file'); });
}

/* ---------- UI ---------- */
const urlInput = document.getElementById('url');
document.getElementById('loadBtn').onclick = ()=>{ const u=urlInput.value.trim(); if(u) loadFromURL(u); };
const fileInput = document.getElementById('fileInput');
document.getElementById('fileBtn').onclick = ()=>{ fileInput.value=''; fileInput.click(); };
fileInput.onchange = ()=>{ const f=fileInput.files?.[0]; if(f) loadBlob(f); };

document.getElementById('doorsToggle').onchange = e=> toggleDoors(e.target.checked);
document.getElementById('hideCeilingToggle').onchange = e=>{
  ceilings.forEach(c=> c.visible = !e.target.checked);
};
document.getElementById('hdrSelect').onchange = (e)=>{
  const v=e.target.value;
  if(!v){ scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture; return; }
  new RGBELoader().load(v, tex=>{
    const env = pmrem.fromEquirectangular(tex).texture;
    scene.environment = env;
    tex.dispose();
  }, undefined, err=> console.warn('HDR load error', err));
};

/* ---------- drag & drop ---------- */
const drop=document.getElementById('drop');
['dragenter','dragover','dragleave','drop'].forEach(ev=>{
  window.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); }, false);
});
window.addEventListener('dragenter', ()=> drop.style.display='flex');
window.addEventListener('dragover',  ()=> drop.style.display='flex');
window.addEventListener('dragleave', e=>{
  if(e.clientX<=0||e.clientY<=0||e.clientX>=innerWidth||e.clientY>=innerHeight){ drop.style.display='none'; }
});
function handleDrop(e){ drop.style.display='none'; const f=e.dataTransfer?.files?.[0]; if(f) loadBlob(f); }
drop.addEventListener('drop', handleDrop);
document.addEventListener('drop', handleDrop);

/* ---------- ?model= ---------- */
const modelURL=new URLSearchParams(location.search).get('model');
if(modelURL){ urlInput.value=modelURL; loadFromURL(modelURL); }

/* ---------- resize & loop ---------- */
function resize(){
  const w=innerWidth,h=innerHeight;
  renderer.setSize(w,h,false);
  camera.aspect=w/h; camera.updateProjectionMatrix();
}
addEventListener('resize', resize);
resize();

renderer.setAnimationLoop(()=>{
  controls.update();
  if(document.getElementById('autoHideToggle').checked) updateAutoHide();
  renderer.render(scene,camera);
});
</script>
</body>
</html>
