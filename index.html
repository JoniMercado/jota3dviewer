<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Room Viewer — v0.2.8</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.164/examples/jsm/"
  }
}
</script>

<style>
  :root{ --topbarH:72px; }

  html,body{height:100%;margin:0}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;
    background:#c9c9c9;color:#222
  }

  /* Top bar */
  #topbar{
    position:fixed; left:12px; top:12px;
    display:inline-flex; gap:8px; flex-wrap:wrap; align-items:center;
    background:rgba(255,255,255,.85); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:10px 12px; z-index:10;
    width:max-content; max-width:calc(100vw - 24px);
  }
  #topbar button{background:#1e68ff;border:none;color:white;padding:6px 10px;border-radius:6px;cursor:pointer}
  #topbar small{opacity:.7}
  #fileInput{display:none}
  #logo{height:48px;margin-right:12px;border-radius:6px}
  label{display:flex;align-items:center;gap:6px}

  /* Right side panel */
  #sidepanel{
    position:fixed; right:12px; top:12px;
    width:380px; max-height:calc(100% - 24px);
    display:flex; flex-direction:column; gap:8px; overflow:auto; z-index:9
  }
  .card{
    background:rgba(255,255,255,.9); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:10px 12px
  }
  details.block>summary{
    list-style:none; cursor:pointer;
    display:flex; align-items:center; gap:8px;
    padding:10px 12px; border-radius:10px;
    background:rgba(255,255,255,.85); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08);
    font-weight:800; font-size:14px; letter-spacing:.4px;
  }
  details.block[open]>summary{background:#f3f6ff;border-color:#ccd9ff}
  .panel{padding:8px 10px}

  /* Rows */
  .act-row{
    display:grid; grid-template-columns: 1fr 200px;
    align-items:center; gap:10px; margin:8px 0;
    font-size:13px;
  }
  .act-row input[type="range"]{ width:200px }

  .mat-row{
    display:grid; grid-template-columns: 1fr auto;
    align-items:center; gap:10px; margin:6px 0; font-size:13px;
  }
  .mat-row select{ padding:4px 6px; border-radius:6px; border:1px solid #cfd6e0; background:#fff; }

  /* Bottom stats */
  #stats{
    position:fixed; left:12px; right:12px; bottom:12px;
    background:rgba(255,255,255,.9); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:8px 12px;
    display:flex; flex-wrap:wrap; align-items:center; gap:10px; z-index:5
  }
  #stats .tag{background:#f2f4f8;border:1px solid #dfe3eb;border-radius:8px;padding:4px 8px;font-size:12px}
  #stats button{background:#eee;border:1px solid #ccc;border-radius:6px;padding:4px 8px;cursor:pointer}

  /* Mobile */
  #statsToggle{
    display:none;
    background:transparent; color:#444; border:1px solid #cfd6e0;
    border-radius:999px; padding:6px 12px; font-weight:600; cursor:pointer;
  }
  #stats.open #statsToggle{ background:#2b7aff; color:#fff; border-color:transparent; }
  #statsContent{ display:flex; flex-wrap:wrap; align-items:center; gap:10px }

  #drop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;border:2px dashed #2a2f36;border-radius:16px;background:rgba(30,104,255,.08);color:#1e68ff;pointer-events:auto;z-index:999}
  canvas{display:block;width:100%;height:100%}

  @media (max-width: 640px){
    #logo{height:36px}
    #topbar{ left:8px; top:8px; padding:8px 10px; gap:6px }

    #sidepanel{ right:8px; top:8px; width:340px; }
    #animCard{ display:none !important; }
    #matCard{  display:none !important; }

    #stats{ left:0; right:0; bottom:0; border-radius:0; padding:8px 10px; gap:8px; }
    #statsToggle{ display:inline-flex; align-items:center; color:#333; }
    #statsContent{ display:none; }

    #stats.open #statsContent{
      display:grid;
      grid-template-columns: repeat(4, auto);
      column-gap:6px; row-gap:4px;
      align-items:center;
    }
    #stats .tag{ padding:3px 6px; font-size:11px; line-height:1.15 }
    #stats #stats-reset{ padding:3px 6px; font-size:11px }
  }
</style>
</head>
<body>
  <div id="topbar">
    <img id="logo" src="https://jonimercado.github.io/threejs-viewer/jota%203d.jpg" alt="Logo">
    <button id="fileBtn">Open .glb/.gltf</button>
    <input type="file" id="fileInput" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" />
    <label style="display:none"><input type="checkbox" id="doorsToggle"> All Doors Open</label>
    <label style="display:none"><input type="checkbox" id="autoHideToggle" checked> Auto-hide front wall</label>
    <label style="display:none"><input type="checkbox" id="hideCeilingToggle" checked> Hide ceiling</label>
    <label><input type="checkbox" id="autoRotateToggle"> Auto-rotate</label>
    <small id="msg"></small>
  </div>

  <div id="sidepanel" style="display:none">
    <details id="matCard" class="block card" open style="display:none">
      <summary>MATERIALES</summary>
      <div class="panel" id="matPanel">
        <div class="mat-row">
          <div>Variant</div>
          <select id="variantSelect"></select>
        </div>
      </div>
    </details>

    <details id="animCard" class="block card" open style="display:none">
      <summary>ACCIONABLES</summary>
      <div class="panel" id="animPanel"></div>
    </details>
  </div>

  <div id="stats">
    <button id="statsToggle" aria-expanded="false">Performance</button>
    <div id="statsContent">
      <span class="tag" id="stat-model">Model: —</span>
      <span class="tag" id="stat-size">Size: —</span>
      <span class="tag" id="stat-tris">Tris: —</span>
      <span class="tag" id="stat-fps">FPS: —</span>
      <span class="tag" id="stat-ms">ms: —</span>
      <span class="tag" id="stat-calls">Calls: —</span>
      <span class="tag" id="stat-geoms">Geoms: —</span>
      <span class="tag" id="stat-text">Tex: —</span>
      <span class="tag" id="stat-rot">Rotate: Off</span>
      <span class="tag" id="stat-bytes">GLB: —</span>
      <button id="stats-reset" title="Reset renderer.info()">Reset</button>
    </div>
  </div>

  <div id="drop">Drop a .glb / .gltf file to view</div>
  <canvas id="c"></canvas>

  <!-- Password Gate -->
  <div id="gate" style="position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:2000;">
    <div style="background:#fff;padding:20px 16px;border-radius:14px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.2);display:grid;gap:10px">
      <div style="font-weight:700">Ingresar</div>
      <input id="gateInput" type="password" placeholder="Password" style="padding:8px 10px;border:1px solid #ddd;border-radius:8px">
      <button id="gateBtn" style="background:#1e68ff;color:#fff;border:none;border-radius:8px;padding:8px 10px;cursor:pointer">Entrar</button>
      <small id="gateMsg" style="color:#c00;min-height:1em"></small>
    </div>
  </div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }     from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader }    from 'three/addons/loaders/DRACOLoader.js';
import { KTX2Loader }     from 'three/addons/loaders/KTX2Loader.js';
import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
import { RoomEnvironment }from 'three/addons/environments/RoomEnvironment.js';
import { KHRMaterialsVariants } from 'three/addons/utils/KHRMaterialsVariants.js';

/* ---------- layout helper ---------- */
const topbar = document.getElementById('topbar');
function updateTopbarVar(){ const h = topbar?.offsetHeight || 72; document.documentElement.style.setProperty('--topbarH', `${h}px`); }
new ResizeObserver(updateTopbarVar).observe(topbar);
addEventListener('load', updateTopbarVar);
addEventListener('resize', updateTopbarVar);

/* ---------- password gate ---------- */
const VIEWER_PASSWORD = 'demo';
const gate   = document.getElementById('gate');
const gInput = document.getElementById('gateInput');
const gBtn   = document.getElementById('gateBtn');
const gMsg   = document.getElementById('gateMsg');
function passOK(p){ const urlKey = new URLSearchParams(location.search).get('key'); return (p && p===VIEWER_PASSWORD)||(urlKey&&urlKey===VIEWER_PASSWORD); }
function unlock(){ gate.style.display='none'; localStorage.setItem('viewer_ok','1'); }
(function initGate(){
  if(localStorage.getItem('viewer_ok')==='1' || passOK(null)){ unlock(); }
  else{
    gBtn?.addEventListener('click', ()=>{ if(passOK(gInput.value)) unlock(); else gMsg.textContent='Password incorrecta'; });
    gInput?.addEventListener('keydown', e=>{ if(e.key==='Enter') gBtn.click(); });
  }
})();

/* ---------- renderer / scene / camera ---------- */
const canvas   = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping      = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type    = THREE.VSMShadowMap;

const scene  = new THREE.Scene();
scene.background = new THREE.Color(0xc9c9c9);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(2,1.2,2);

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,0.6,0);
controls.enableDamping = true;
controls.autoRotate = false;
controls.autoRotateSpeed = 0.8;

scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.0));
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

/* Luz direccional para sombras */
let dirLight = null;

/* ---------- loaders ---------- */
const draco  = new DRACOLoader().setDecoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/draco/');
const ktx2   = new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/basis/').detectSupport(renderer);
const loader = new GLTFLoader().setDRACOLoader(draco).setKTX2Loader(ktx2);

/* ---------- state ---------- */
let current=null, mixer=null;
let allNodes=[], ceilings=[], wallRoots=[], lastHiddenWalls=new Set();
let assetRoot=null, animGroups=[], doorGroups=[];
const objectToGroup=new Map(), objectToDoor=new Map();
let shadowPlane=null, lastGLBBytes=null;

/* ---------- KHR variants ---------- */
const variantSelect = document.getElementById('variantSelect');
let availableVariants = [];   // strings
let parser = null;            // gltf.parser for variants
let modelKey = '';            // para persistir selección

/* ---------- stats els ---------- */
const statModel = document.getElementById('stat-model');
const statSize  = document.getElementById('stat-size');
const statTris  = document.getElementById('stat-tris');
const statFPS   = document.getElementById('stat-fps');
const statMS    = document.getElementById('stat-ms');
const statCalls = document.getElementById('stat-calls');
const statGeoms = document.getElementById('stat-geoms');
const statText  = document.getElementById('stat-text');
const statRot   = document.getElementById('stat-rot');
const statBytes = document.getElementById('stat-bytes');
document.getElementById('stats-reset')?.addEventListener('click', ()=> renderer.info.reset());
let fpsEMA = 0;

/* ---------- UI mode ---------- */
function setUIMode(mode){
  const side  = document.getElementById('sidepanel');
  const animCard = document.getElementById('animCard');
  const matCard  = document.getElementById('matCard');

  if(mode==='clean'){ side.style.display='none'; removeShadowSystem(); return; }
  const isAsset = (mode === 'asset');
  side.style.display   = isAsset ? '' : 'none';
  animCard.style.display = isAsset ? '' : 'none';
  matCard.style.display  = isAsset ? '' : 'none';
  if(!isAsset) removeShadowSystem();
  updateTopbarVar();
}
setUIMode('clean');

/* ---------- helpers ---------- */
function setMsg(t){ document.getElementById('msg').textContent = t || ''; }
function disposeMat(m){ ['map','normalMap','roughnessMap','metalnessMap','occlusionMap','emissiveMap'].forEach(k=>m[k]?.dispose?.()); }
function clearModel(){
  if(!current) return;
  scene.remove(current);
  current.traverse?.(o=>{ if(o.geometry) o.geometry.dispose(); const m=o.material; if(m) (Array.isArray(m)?m:[m]).forEach(disposeMat); });
  current=null; allNodes=[]; ceilings=[]; wallRoots=[]; lastHiddenWalls.clear();
  removeAssetUI(); removeDoorUI(); removeShadowSystem(); objectToGroup.clear(); objectToDoor.clear();
  // KHR variants
  availableVariants=[]; parser=null; variantSelect.innerHTML=''; document.getElementById('matCard').style.display='none';
  // stats
  lastGLBBytes=null; statModel.textContent='Model: —'; statSize.textContent='Size: —'; statTris.textContent='Tris: —'; statBytes.textContent='GLB: —';
  mixer=null;
}
function triCount(obj){ let t=0; obj.traverse(o=>{ if(o.isMesh){ const g=o.geometry; t += g?.index ? g.index.count/3 : (g?.attributes?.position?.count||0)/3; }}); return Math.round(t); }
function updateStats(sizeVec){
  const tris = current ? triCount(current).toLocaleString() : '—';
  const sz   = sizeVec ? `${sizeVec.x.toFixed(2)}×${sizeVec.y.toFixed(2)}×${sizeVec.z.toFixed(2)} m` : '—';
  statTris.textContent = `Tris: ${tris}`;
  statSize.textContent = `Size: ${sz}`;
}
function humanBytes(b){ if(b==null) return '—'; const u=['B','KB','MB','GB']; let i=0, n=b; while(n>=1024 && i<u.length-1){ n/=1024; i++; } return `${n.toFixed(n<10&&i>0?1:0)} ${u[i]}`; }
function stripDoorPrefix(s){ return s?.replace(/^door_/i,'') ?? s; }
function guessModeFromFilename(name){ if(!name) return null; const lower=name.toLowerCase(); if(/_(00|0[0-9])\.(glb|gltf)$/.test(lower)) return 'room'; return null; }

/* ---------- minimal room helpers kept ---------- */
function extractIndex(name){ if(!name) return null; let m=name.match(/door(\d+)/i); if(m) return m[1]; m=name.match(/panel(\d+)/i); if(m) return m[1]; m=name.match(/(\d+)(?!.*\d)/); return m?m[1]:null; }
function extractSide(name){ if(!name) return null; if(/leftpanel/i.test(name)||/_left/i.test(name)) return 'left'; if(/rightpanel/i.test(name)||/_right/i.test(name)) return 'right'; return null; }
function doorGroupKey(name){ if(!name) return ''; const m=name.match(/^(?:door_)?(.+)$/i); return (m?m[1]:name).toLowerCase(); }
function reparentKeepWorld(child,newParent){
  child.updateMatrixWorld(true);
  const childWorld=child.matrixWorld.clone();
  newParent.updateMatrixWorld(true); newParent.add(child);
  const invP=newParent.matrixWorld.clone().invert();
  const local=new THREE.Matrix4().multiplyMatrices(invP,childWorld);
  local.decompose(child.position,child.quaternion,child.scale);
  child.updateMatrixWorld(true);
}

/* ---------- asset UI (morphs) ---------- */
function removeAssetUI(){ animGroups=[]; const p=document.getElementById('animPanel'); if(p) p.innerHTML=''; }
function collectMorphMeshes(root){ const out=[]; root.traverse(o=>{ if(o.isMesh && o.morphTargetInfluences && o.morphTargetDictionary) out.push(o); }); return out; }
function uniqueNamesFromMeshes(meshes){ const set=new Set(); meshes.forEach(m=>{ const d=m.morphTargetDictionary; if(!d) return; Object.keys(d).forEach(k=>set.add(k)); }); return Array.from(set); }
function findAnimRoots(asset){ const arr=[]; asset.traverse(o=>{ if(o!==asset && o.name && /^anim_/i.test(o.name)) arr.push(o); }); return arr; }
function stripAnimPrefix(s){ return s?.replace(/^anim_/i,'') ?? s; }

/* ---------- Doors from clips ---------- */
function removeDoorUI(){ doorGroups=[]; }
function buildDoorControlsFromClips(root, clips){
  if(!clips?.length) return;
  const panel=document.getElementById('animPanel'); if(!panel) return;

  clips.filter(c=>/^door_/i.test(c.name)).forEach((clip)=>{
    const track=clip.tracks[0]; if(!track) return;
    if(!mixer) mixer=new THREE.AnimationMixer(root);
    const action=mixer.clipAction(clip);
    action.clampWhenFinished=true; action.enabled=true; action.play(); action.paused=true; action.time=0;
    let targetNode=null; const path=track.name.split('.')[0];
    root.traverse(o=>{ if(!targetNode && o.name===path) targetNode=o; });
    if(!targetNode) targetNode=root;
    targetNode.traverse(n=> objectToDoor.set(n, doorGroups.length));
    doorGroups.push({ name: stripDoorPrefix(clip.name), clip, action, node: targetNode, duration: clip.duration, value:0, slider:null });
  });

  renderActionsPanel();
}
function renderActionsPanel(){
  const panel=document.getElementById('animPanel'); if(!panel) return;
  panel.innerHTML='';

  // Puertas
  doorGroups.forEach(g=>{
    const row=document.createElement('div'); row.className='act-row';
    const name=document.createElement('div'); name.textContent=g.name; row.appendChild(name);
    const slider=document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='1'; slider.step='0.01'; slider.value=String(g.value);
    slider.oninput=()=> setDoorValue(g, parseFloat(slider.value));
    row.appendChild(slider); g.slider=slider; panel.appendChild(row);
  });

  // Morphs (un slider por grupo anim_)
  if(!assetRoot){ document.getElementById('animCard').style.display='none'; return; }
  const animRoots=findAnimRoots(assetRoot); const groups=[]; objectToGroup.clear();
  animRoots.forEach((ar,gi)=>{
    const meshes=collectMorphMeshes(ar); if(!meshes.length) return;
    const morphNames=uniqueNamesFromMeshes(meshes); if(!morphNames.length) return;
    ar.traverse(n=> objectToGroup.set(n,gi));
    groups.push({ name: ar.name, node: ar, meshes, morphNames, activeMorph: morphNames[0], sliderEl:null, selectEl:null, tween:null });
  });
  animGroups=groups;

  animGroups.forEach(group=>{
    const row=document.createElement('div'); row.className='act-row';
    const label=document.createElement('div'); label.textContent=stripAnimPrefix(group.name); row.appendChild(label);
    const slider=document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='1'; slider.step='0.01'; slider.value='0';
    slider.oninput=()=>{ const val=parseFloat(slider.value);
      group.meshes.forEach(m=>{ const d=m.morphTargetDictionary, inf=m.morphTargetInfluences; if(!d||!inf) return; if(group.activeMorph in d){ inf[d[group.activeMorph]]=val; m.needsUpdate=true; }});
    };
    row.appendChild(slider); group.sliderEl=slider; panel.appendChild(row);
  });

  document.getElementById('animCard').style.display='';
}
function setDoorValue(group,value){
  group.value=THREE.MathUtils.clamp(value,0,1);
  if(!group.action) return;
  group.action.paused=true;
  group.action.time=group.duration*group.value;
  group.action.syncWith(group.action);
  if(group.slider) group.slider.value=String(group.value);
}
function tweenDoor(group,toValue,durationMs=500){
  const from=group.value??0, start=performance.now();
  const step=(t)=>{ const k=Math.min(1,(t-start)/durationMs); const v=from+(toValue-from)*k; setDoorValue(group,v); if(k<1) requestAnimationFrame(step); };
  requestAnimationFrame(step);
}

/* ---------- sombras ---------- */
function setCastShadow(obj,val){ obj.traverse(o=>{ if(o.isMesh){ o.castShadow=!!val; }}); }
function ensureShadowSystem(){
  if(!assetRoot) return;
  if(!dirLight){
    dirLight=new THREE.DirectionalLight(0xffffff,0.5);
    dirLight.castShadow=true; dirLight.shadow.mapSize.set(2048,2048);
    dirLight.shadow.bias=-0.00015; dirLight.shadow.normalBias=0.015;
    scene.add(dirLight);
  }
  if(!shadowPlane){
    const mat=new THREE.ShadowMaterial({ opacity:0.07 });
    const geo=new THREE.PlaneGeometry(1,1);
    shadowPlane=new THREE.Mesh(geo,mat);
    shadowPlane.rotation.x=-Math.PI/2;
    shadowPlane.receiveShadow=true; shadowPlane.renderOrder=-1;
    scene.add(shadowPlane);
  }
  const box=new THREE.Box3().setFromObject(assetRoot);
  const size=box.getSize(new THREE.Vector3());
  const ctr =box.getCenter(new THREE.Vector3());
  shadowPlane.position.set(ctr.x, box.min.y+0.0001, ctr.z);
  shadowPlane.scale.set(size.x*1.05, size.z*1.05, 1);

  // luz sigue la cámara
  const dir=new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
  const elev=0.9, lateral=0.25;
  dirLight.position.set(ctr.x + dir.x*size.x*lateral, box.max.y + size.y*1.4*elev, ctr.z + dir.z*size.z*lateral);
  dirLight.target.position.set(ctr.x, ctr.y, ctr.z);
  scene.add(dirLight.target);

  dirLight.shadow.radius=4.0;
  const cam=dirLight.shadow.camera; const r=Math.max(size.x,size.z)*0.65;
  cam.left=-r; cam.right=r; cam.top=r; cam.bottom=-r; cam.near=0.1; cam.far=size.y*4.0; cam.updateProjectionMatrix();
  setCastShadow(assetRoot,true);
}
function removeShadowSystem(){
  if(shadowPlane){ shadowPlane.geometry.dispose(); shadowPlane.material.dispose(); scene.remove(shadowPlane); shadowPlane=null; }
  if(dirLight){ scene.remove(dirLight.target); scene.remove(dirLight); dirLight=null; }
}

/* ---------- KHR variants helpers ---------- */
function listAllVariants(root){
  // Recorre todas las mallas y acumula el set de variantes
  const set = new Set();
  root.traverse(node=>{
    if(!node.isMesh) return;
    const vars = KHRMaterialsVariants.getVariants(node);
    if(vars && vars.length) vars.forEach(v=> set.add(v));
  });
  return Array.from(set);
}
function applyVariantToScene(root, variantName){
  if(!parser) return;
  root.traverse(node=>{
    if(!node.isMesh) return;
    // si la malla no tiene esa variante, el helper conserva el material actual
    KHRMaterialsVariants.selectVariant(node, parser, variantName);
  });
}

/* ---------- placing ---------- */
function place(root, gltf){
  // ocultar colliders/ceilings
  root.traverse(o=>{
    if(o.isMesh && /collider/i.test(o.name)) o.visible=false;
    if(o.isMesh && /^ceiling\d*$/i.test(o.name)) o.visible=false;
  });

  new THREE.Box3().setFromObject(root).getCenter(root.position).multiplyScalar(-1);
  const box=new THREE.Box3().setFromObject(root);
  const size=box.getSize(new THREE.Vector3());
  root.position.y -= box.min.y;

  allNodes=[]; root.traverse(o=>{ if(o.name) allNodes.push(o); });
  ceilings = allNodes.filter(o=>/^ceiling\d*$/i.test(o.name));
  wallRoots= allNodes.filter(o=>/^wall\d+$/i.test(o.name));

  current=root; scene.add(root);

  // detectar model_
  assetRoot=null; current.traverse(o=>{ if(!assetRoot && o.name && /^model_/i.test(o.name)) assetRoot=o; });

  // KHR variants UI
  availableVariants = [];
  parser = gltf?.parser || null;
  if(assetRoot && parser){
    availableVariants = listAllVariants(assetRoot);
    buildMaterialsUI_KHR();
  }else{
    document.getElementById('matCard').style.display='none';
  }

  // puertas desde clips + morphs
  removeDoorUI();
  if(assetRoot){
    buildDoorControlsFromClips(current, gltf?.animations||[]);
    renderActionsPanel();
    ensureShadowSystem();
  } else {
    removeAssetUI(); removeShadowSystem(); objectToGroup.clear(); objectToDoor.clear();
  }

  mixer = mixer || new THREE.AnimationMixer(current);

  const maxDim=Math.max(size.x,size.y,size.z);
  camera.position.setScalar(maxDim*1.6).setY(maxDim*0.8);
  controls.target.copy(new THREE.Box3().setFromObject(root).getCenter(new THREE.Vector3()));
  controls.update();

  statModel.textContent = `Model: ${root.name || '(scene)'}`;
  updateStats(size);
  updateTopbarVar();
}

/* ---------- Materials UI (KHR) ---------- */
function buildMaterialsUI_KHR(){
  const card = document.getElementById('matCard');
  const sel  = document.getElementById('variantSelect');
  if(!availableVariants.length){ card.style.display='none'; return; }
  card.style.display='';

  sel.innerHTML='';
  availableVariants.forEach(n=>{
    const opt=document.createElement('option'); opt.value=n; opt.textContent=n; sel.appendChild(opt);
  });

  // restore last
  const saved = modelKey ? localStorage.getItem(`khrvariant:${modelKey}`) : null;
  const initial = (saved && availableVariants.includes(saved)) ? saved : availableVariants[0];
  sel.value = initial; applyVariantToScene(assetRoot, initial);

  sel.onchange = ()=>{ applyVariantToScene(assetRoot, sel.value); if(modelKey) localStorage.setItem(`khrvariant:${modelKey}`, sel.value); };

  // API pública
  window.MaterialAPI = {
    setVariant: (name)=>{ if(availableVariants.includes(name)){ sel.value=name; sel.onchange(); } },
    getVariants: ()=> [...availableVariants]
  };
}

/* ---------- ray helpers ---------- */
const ray=new THREE.Raycaster(), mouse=new THREE.Vector2(); let downPos=null;
function screenToNDC(e){ const r=renderer.domElement.getBoundingClientRect(); mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1; }
function findMorphGroupFromObject(obj){ let p=obj; while(p){ if(objectToGroup.has(p)) return objectToGroup.get(p); p=p.parent; } return null; }
function findDoorGroupFromObject(obj){ let p=obj; while(p){ if(objectToDoor.has(p)) return objectToDoor.get(p); p=p.parent; } return null; }

/* ---------- clicks ---------- */
canvas.addEventListener('pointerdown', e=>{ downPos={x:e.clientX,y:e.clientY}; });
canvas.addEventListener('pointerup', e=>{
  if(controls.dragging) return;
  if(downPos && (Math.hypot(e.clientX-downPos.x, e.clientY-downPos.y)>3)) return;
  const rect=renderer.domElement.getBoundingClientRect();
  if(e.clientY < rect.top + (topbar?.offsetHeight||0)) return;

  screenToNDC(e); ray.setFromCamera(mouse,camera);
  const intersects=ray.intersectObject(current ?? scene,true);
  if(!intersects.length) return;
  const obj=intersects[0].object;

  // puertas primero
  const dIdx=findDoorGroupFromObject(obj);
  if(dIdx!=null){ const g=doorGroups[dIdx]; const target=(g.value>=0.5)?0:1; tweenDoor(g,target,500); return; }

  // morphs
  if(assetRoot){
    const gi=findMorphGroupFromObject(obj);
    if(gi!=null){
      const group=animGroups[gi];
      const probe=group.meshes.find(m=>m.morphTargetDictionary && group.activeMorph in m.morphTargetDictionary);
      if(probe){
        const idx=probe.morphTargetDictionary[group.activeMorph];
        const cur=probe.morphTargetInfluences[idx]??0;
        const target=(cur>=0.5)?0:1;
        const start=performance.now(), from=cur;
        const step=(t)=>{ const k=Math.min(1,(t-start)/500); const v=from+(target-from)*k;
          group.meshes.forEach(m=>{ const d=m.morphTargetDictionary, inf=m.morphTargetInfluences; if(!d||!inf) return; if(group.activeMorph in d){ inf[d[group.activeMorph]]=v; m.needsUpdate=true; }});
          if(group.sliderEl) group.sliderEl.value=String(v);
          if(k<1) requestAnimationFrame(step);
        }; requestAnimationFrame(step);
      }
    }
  }
});

/* ---------- auto-hide (rooms) ---------- */
function wallRootOf(obj){ let p=obj; while(p){ if(/^wall\d+$/i.test(p.name)) return p; p=p.parent; } return null; }
function sampleFrontWalls(){
  if(!wallRoots?.length) return new Set();
  let closest=null, closestDist=Infinity;
  const distToTarget=camera.position.distanceTo(controls.target);
  const samples=[{x:0,y:0},{x:0.14,y:0},{x:-0.14,y:0},{x:0,y:0.14},{x:0,y:-0.14}];
  for(const ndc of samples){
    ray.setFromCamera(ndc,camera);
    const hits=ray.intersectObjects(wallRoots,true);
    if(hits.length){
      const h=hits[0];
      if(h.distance<distToTarget*0.995 && h.distance<closestDist){ closest=wallRootOf(h.object); closestDist=h.distance; }
    }
  }
  return closest? new Set([closest]) : new Set();
}
function updateAutoHide(){
  const autoHToggle=document.getElementById('autoHideToggle');
  if(!autoHToggle || autoHToggle.closest('label').style.display==='none') return;
  if(!autoHToggle.checked || !current) return;
  const front=sampleFrontWalls();
  for(const wr of Array.from(lastHiddenWalls)){ if(!front.has(wr)){ wr.visible=true; lastHiddenWalls.delete(wr);} }
  for(const wr of front){ if(!lastHiddenWalls.has(wr)){ wr.visible=false; lastHiddenWalls.add(wr);} }
}

/* ---------- loading ---------- */
function loadBlob(file){
  setUIMode('clean'); setMsg('Loading local file…'); clearModel();
  const pre=guessModeFromFilename(file.name); if(pre) setUIMode(pre);
  lastGLBBytes=file.size; statBytes.textContent=`GLB: ${humanBytes(lastGLBBytes)}`;
  modelKey = `${file.name}|${file.size}`;
  const url=URL.createObjectURL(file);
  loader.load(url, (gltf)=>{
      // guardar parser para variants
      parser = gltf.parser;
      place(gltf.scene, gltf);
      setMsg(file.name);
      URL.revokeObjectURL(url);

      // restaurar la última variante si existiera
      const saved = modelKey ? localStorage.getItem(`khrvariant:${modelKey}`) : null;
      if(saved && availableVariants.includes(saved)){
        variantSelect.value = saved;
        variantSelect.onchange();
      }
    },
    undefined,
    e=>{ console.error(e); setMsg('Error with local file'); }
  );
}

/* ---------- UI ---------- */
const fileInput=document.getElementById('fileInput');
document.getElementById('fileBtn').onclick=()=>{ fileInput.value=''; fileInput.click(); };
fileInput.onchange=()=>{ const f=fileInput.files?.[0]; if(f) loadBlob(f); };
document.getElementById('hideCeilingToggle').onchange=e=>{ ceilings.forEach(c=> c.visible=!e.target.checked); };
document.getElementById('autoRotateToggle').onchange=e=>{ controls.autoRotate=e.target.checked; statRot.textContent=`Rotate: ${e.target.checked?'On':'Off'}`; };

/* ---------- drag & drop ---------- */
const drop=document.getElementById('drop');
['dragenter','dragover','dragleave','drop'].forEach(ev=>{ window.addEventListener(ev,e=>{ e.preventDefault(); e.stopPropagation(); }, false); });
window.addEventListener('dragenter', ()=> drop.style.display='flex');
window.addEventListener('dragover',  ()=> drop.style.display='flex');
window.addEventListener('dragleave', e=>{ if(e.clientX<=0||e.clientY<=0||e.clientX>=innerWidth||e.clientY>=innerHeight){ drop.style.display='none'; }});
drop.addEventListener('drop', e=>{ e.preventDefault(); e.stopPropagation(); drop.style.display='none'; const f=e.dataTransfer?.files?.[0]; if(f) loadBlob(f); });

/* ---------- stats toggle (mobile) ---------- */
const statsEl=document.getElementById('stats');
const statsToggle=document.getElementById('statsToggle');
function isMobile(){ return window.matchMedia('(max-width: 640px)').matches; }
function applyStatsMode(){ if(isMobile()){ statsEl.classList.remove('open'); statsToggle.setAttribute('aria-expanded','false'); } else { statsEl.classList.add('open'); statsToggle.setAttribute('aria-expanded','true'); } }
statsToggle.addEventListener('click', ()=>{ if(!isMobile()) return; const open=statsEl.classList.toggle('open'); statsToggle.setAttribute('aria-expanded', open?'true':'false'); });
addEventListener('resize', applyStatsMode); applyStatsMode();

/* ---------- resize & loop ---------- */
function resize(){ const w=innerWidth,h=innerHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); updateTopbarVar(); }
addEventListener('resize', ()=>{ resize(); ensureShadowSystem(); }); resize();

/* ---------- perf loop ---------- */
let lastT=performance.now();
renderer.setAnimationLoop(()=>{
  const now=performance.now(), dt=now-lastT; lastT=now;
  const fpsInst=1000/dt; fpsEMA = fpsEMA ? (fpsEMA*0.9 + fpsInst*0.1) : fpsInst;

  const info=renderer.info;
  statFPS.textContent=`FPS: ${fpsEMA.toFixed(0)}`;
  statMS.textContent =`ms: ${dt.toFixed(1)}`;
  statCalls.textContent=`Calls: ${info.render.calls}`;
  statGeoms.textContent=`Geoms: ${info.memory.geometries}`;
  statText.textContent =`Tex: ${info.memory.textures}`;
  statRot.textContent  =`Rotate: ${controls.autoRotate ? 'On' : 'Off'}`;

  if(mixer) mixer.update(dt/1000);
  controls.update();
  updateAutoHide();
  ensureShadowSystem();
  renderer.render(scene,camera);
});
</script>
</body>
</html>
