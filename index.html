<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Room Viewer — v0.2.5</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
  }
}
</script>

<style>
  :root{
    --topbarH:72px;
    --stackGap:8px;
    --padCard:10px 12px;
    --radiusCard:12px;
    --edgeGap:8px;
  }

  html,body{height:100%;margin:0}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;
    background:#c9c9c9;color:#222
  }

  /* Top bar */
  #topbar{
    position:fixed; left:12px; top:12px;
    display:inline-flex; gap:8px; flex-wrap:wrap; align-items:center;
    background:rgba(255,255,255,.85); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:10px 12px; z-index:10;
    width:max-content; max-width:calc(100vw - 24px);
  }
  #topbar button{background:#1e68ff;border:none;color:white;padding:6px 10px;border-radius:6px;cursor:pointer}
  #topbar small{opacity:.7}
  #fileInput{display:none}
  #logo{height:48px;margin-right:12px;border-radius:6px}
  label{display:flex;align-items:center;gap:6px}

  /* Right side panel (ACCIONABLES) */
  #sidepanel{
    position:fixed; right:12px; top:12px;
    width:380px; max-height:calc(100% - 24px);
    display:flex; flex-direction:column; gap:8px; overflow:auto; z-index:9
  }
  .card{
    background:rgba(255,255,255,.9); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:10px 12px
  }
  details.block>summary{
    list-style:none; cursor:pointer;
    display:flex; align-items:center; gap:8px;
    padding:10px 12px; border-radius:10px;
    background:rgba(255,255,255,.85); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08);
    font-weight:800; font-size:14px; letter-spacing:.4px;
  }
  details.block[open]>summary{background:#f3f6ff;border-color:#ccd9ff}
  .panel{padding:8px 10px}

  /* ACCIONABLES list */
  .act-row{
    display:grid; grid-template-columns: 1fr 200px;
    align-items:center; gap:10px; margin:8px 0;
    font-size:13px;
  }
  .act-row input[type="range"]{ width:200px }
  .muted{opacity:.7;font-size:12px}
  .act-row select{
    width:200px; padding:6px 8px;
    border:1px solid #ccc; border-radius:6px;
    background:#f5f5f5; color:#111; font:inherit;
  }

  /* VARIANTES */
  #variantsCard{ z-index:9 }
  #variantsPanel .act-row{ margin-top:6px }

  /* Swatch bar (móvil) */
  .swatch-bar{
    display:none; /* visible solo en móvil */
    gap:10px; align-items:center; justify-content:center; flex-wrap:wrap;
    padding:6px 0 2px;
  }
  .swatch{
    width:42px; height:42px; border-radius:999px;
    border:2px solid rgba(0,0,0,.15);
    box-shadow:0 1px 3px rgba(0,0,0,.1);
    position:relative; cursor:pointer; overflow:hidden;
    background:#eee;
  }
  .swatch-inner{
    position:absolute; inset:-2%;  /* hace la imagen ligeramente más grande para cubrir el círculo */
    border-radius:inherit;
    background-size:cover; background-position:center; background-repeat:no-repeat;
    transform:translateZ(0);
  }
  .swatch.selected{
    outline:2px solid #2b7aff; outline-offset:2px;
    border-color:transparent;
  }

  /* Bottom stats / performance */
  #stats{
    position:fixed; left:12px; right:12px; bottom:12px;
    background:rgba(255,255,255,.9); backdrop-filter:blur(6px);
    border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:8px 12px;
    display:flex; flex-wrap:wrap; align-items:center; gap:10px; z-index:5
  }
  #stats .tag{background:#f2f4f8;border:1px solid #dfe3eb;border-radius:8px;padding:4px 8px;font-size:12px}
  #stats button{background:#eee;border:1px solid #ccc;border-radius:12px;padding:6px 12px;cursor:pointer;font-weight:700}
  #stat-variantLabel{ margin-left:4px; opacity:.8 }

  #drop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;border:2px dashed #2a2f36;border-radius:16px;background:rgba(30,104,255,.08);color:#1e68ff;pointer-events:auto;z-index:999}
  canvas{display:block;width:100%;height:100%}

  /* ---------- Mobile tweaks ---------- */
  @media (max-width: 640px){
    :root{ --stackGap:8px; --edgeGap:8px; }

    #logo{height:36px}

    /* Topbar: márgenes simétricos, no a pantalla completa */
    #topbar{
      left:var(--edgeGap); right:var(--edgeGap); top:var(--stackGap);
      width:auto; max-width:unset; border-radius:12px;
      display:flex; flex-wrap:wrap; gap:8px;
    }

    /* Ocultar ACCIONABLES en móvil */
    #animCard{ display:none !important; }

    /* VARIANTES card en móvil: debajo del topbar,
       con la misma separación que del borde superior */
    #variantsCard.mobile{
      position:fixed;
      left:var(--edgeGap); right:var(--edgeGap);
      top:calc(var(--stackGap) + var(--topbarH) + var(--stackGap));
      width:auto; max-width:unset;
      border-radius:12px;
      padding:8px 10px;
    }
    #variantsCard.mobile details.block>summary{
      padding:8px 10px; font-size:13px;
    }

    /* En móvil se muestra la barra de swatches y se oculta el select */
    .swatch-bar{ display:flex; }
    #variantsSelectRow{ display:none; }

    /* Barra inferior móvil */
    #stats{ left:0; right:0; bottom:0; border-radius:0; padding:8px 10px; gap:8px; }
    #statsToggle{ display:inline-flex; align-items:center; color:#333; background:transparent; border:1px solid #cfd6e0; border-radius:999px; padding:6px 12px; font-weight:600; cursor:pointer; }
    #statsContent{ display:none; }
    #stats.open #statsContent{
      display:grid; grid-template-columns: repeat(4, auto); column-gap:6px; row-gap:4px; align-items:center;
    }
    #stats .tag{ padding:3px 6px; font-size:11px; line-height:1.15 }
    #stats #stats-reset{ padding:3px 6px; font-size:11px }
  }
</style>
</head>
<body>
  <!-- Top row -->
  <div id="topbar">
    <img id="logo" src="https://jonimercado.github.io/threejs-viewer/jota%203d.jpg" alt="Logo">
    <button id="fileBtn">Open .glb/.gltf</button>
    <input type="file" id="fileInput" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" />
    <!-- Rooms controls (ocultos cuando es asset) -->
    <label style="display:none"><input type="checkbox" id="doorsToggle"> All Doors Open</label>
    <label style="display:none"><input type="checkbox" id="autoHideToggle" checked> Auto-hide front wall</label>
    <label style="display:none"><input type="checkbox" id="hideCeilingToggle" checked> Hide ceiling</label>
    <small id="msg"></small>
  </div>

  <!-- Side panel: ACCIONABLES + VARIANTES (desktop) -->
  <div id="sidepanel" style="display:none">
    <details id="animCard" class="block card" open style="display:none">
      <summary>ACCIONABLES</summary>
      <div class="panel" id="animPanel"></div>
    </details>

    <details id="variantsCard" class="block card" open style="display:none">
            <div class="panel" id="variantsPanel">
        <!-- Desktop select -->
        <div class="act-row" id="variantsSelectRow">
          <div>Material</div>
          <select id="variantSelect"></select>
        </div>
        <!-- Mobile swatches -->
        <div class="swatch-bar" id="swatchBar"></div>
      </div>
    </details>
  </div>

  <!-- Bottom stats / performance -->
  <div id="stats">
    <button id="statsToggle" aria-expanded="false" style="display:none">Performance</button>
    <span id="stat-variantLabel" class="tag">Variant: —</span>
    <div id="statsContent">
      <span class="tag" id="stat-model">Model: —</span>
      <span class="tag" id="stat-size">Size: —</span>
      <span class="tag" id="stat-tris">Tris: —</span>
      <span class="tag" id="stat-fps">FPS: —</span>
      <span class="tag" id="stat-ms">ms: —</span>
      <span class="tag" id="stat-calls">Calls: —</span>
      <span class="tag" id="stat-geoms">Geoms: —</span>
      <span class="tag" id="stat-text">Tex: —</span>
      <span class="tag" id="stat-file">File: —</span>
      <span class="tag" id="stat-bytes">GLB: —</span>
      <button id="stats-reset" title="Reset renderer.info()">Reset</button>
    </div>
  </div>

  <div id="drop">Drop a .glb / .gltf file to view</div>
  <canvas id="c"></canvas>

  <!-- Password Gate -->
  <div id="gate" style="position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:2000;">
    <div style="background:#fff;padding:20px 16px;border-radius:14px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.2);display:grid;gap:10px">
      <div style="font-weight:700">Ingresar</div>
      <input id="gateInput" type="password" placeholder="Password" style="padding:8px 10px;border:1px solid #ddd;border-radius:8px">
      <button id="gateBtn" style="background:#1e68ff;color:#fff;border:none;border-radius:8px;padding:8px 10px;cursor:pointer">Entrar</button>
      <small id="gateMsg" style="color:#c00;min-height:1em"></small>
    </div>
  </div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }     from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader }    from 'three/addons/loaders/DRACOLoader.js';
import { KTX2Loader }     from 'three/addons/loaders/KTX2Loader.js';
import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
import { RoomEnvironment }from 'three/addons/environments/RoomEnvironment.js';

/* ---------- layout helper ---------- */
const topbar = document.getElementById('topbar');
const variantsCard = document.getElementById('variantsCard');
function updateTopbarVar(){
  const h = topbar?.offsetHeight || 72;
  document.documentElement.style.setProperty('--topbarH', `${h}px`);
}
new ResizeObserver(updateTopbarVar).observe(topbar);
addEventListener('load', updateTopbarVar);
addEventListener('resize', updateTopbarVar);

/* mover VARIANTES según breakpoint */
const mql = window.matchMedia('(max-width: 640px)');
function placeVariantsForViewport(){
  if(!variantsCard) return;
  if(mql.matches){
    variantsCard.classList.add('mobile');
    variantsCard.style.display = variantsCard.dataset.hasVariants === '1' ? '' : 'none';
    document.body.appendChild(variantsCard);
  } else {
    variantsCard.classList.remove('mobile');
    const sidepanel = document.getElementById('sidepanel');
    sidepanel.appendChild(variantsCard);
    variantsCard.style.display = variantsCard.dataset.hasVariants === '1' ? '' : 'none';
  }
  updateTopbarVar();
}
mql.addEventListener('change', placeVariantsForViewport);

/* ---------- password gate ---------- */
const VIEWER_PASSWORD = 'demo';
const gate   = document.getElementById('gate');
const gInput = document.getElementById('gateInput');
const gBtn   = document.getElementById('gateBtn');
const gMsg   = document.getElementById('gateMsg');
function passOK(p){
  const urlKey = new URLSearchParams(location.search).get('key');
  return (p && p === VIEWER_PASSWORD) || (urlKey && urlKey === VIEWER_PASSWORD);
}
function unlock(){ gate.style.display = 'none'; localStorage.setItem('viewer_ok','1'); }
(function initGate(){
  if(localStorage.getItem('viewer_ok') === '1' || passOK(null)){ unlock(); }
  else{
    gBtn?.addEventListener('click', ()=>{ if(passOK(gInput.value)) unlock(); else gMsg.textContent='Password incorrecta'; });
    gInput?.addEventListener('keydown', (e)=>{ if(e.key==='Enter') gBtn.click(); });
  }
})();

/* ---------- renderer / scene / camera ---------- */
const canvas   = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping      = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type    = THREE.VSMShadowMap;

const scene  = new THREE.Scene();
scene.background = new THREE.Color(0xc9c9c9);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(2,1.2,2);

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,0.6,0);
controls.enableDamping = true;
controls.autoRotate = false;
controls.autoRotateSpeed = 0.8;

/* Luces (más exposición indirecta) */
scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.3));
scene.add(new THREE.AmbientLight(0xffffff, 0.5));

/* Luz direccional para sombras (modo asset) */
let dirLight = null;

/* ---------- loaders ---------- */
const draco  = new DRACOLoader().setDecoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/draco/');
const ktx2   = new KTX2Loader().setTranscoderPath('https://unpkg.com/three@0.164/examples/jsm/libs/basis/').detectSupport(renderer);
const loader = new GLTFLoader().setDRACOLoader(draco).setKTX2Loader(ktx2);

/* ---------- state ---------- */
let current = null;
let mixer   = null;
let allNodes = [], doorPanels = [], doorVariantPairs = [], ceilings = [], wallRoots = [];
let lastHiddenWalls = new Set();
let assetRoot = null;
let animGroups = [];             // morph groups
let doorGroups = [];             // door groups from clips
let shadowPlane = null;
const objectToGroup = new Map(); // for morph groups
const objectToDoor  = new Map(); // for door groups
let lastGLBBytes = null;

/* Variants UI refs */
const variantSelect = document.getElementById('variantSelect');
const swatchBar     = document.getElementById('swatchBar');
variantsCard.dataset.hasVariants = '0';

/* ---------- Bottom stats / performance elements ---------- */
const statVariant = document.getElementById('stat-variantLabel');
const statModel = document.getElementById('stat-model');
const statSize  = document.getElementById('stat-size');
const statTris  = document.getElementById('stat-tris');
const statFPS   = document.getElementById('stat-fps');
const statMS    = document.getElementById('stat-ms');
const statCalls = document.getElementById('stat-calls');
const statGeoms = document.getElementById('stat-geoms');
const statText  = document.getElementById('stat-text');
const statFile  = document.getElementById('stat-file');
const statBytes = document.getElementById('stat-bytes');
document.getElementById('stats-reset')?.addEventListener('click', ()=> renderer.info.reset());
let fpsEMA = 0;

/* ---------- UI mode ---------- */
function setUIMode(mode){
  const lab = id => document.getElementById(id)?.closest('label');
  const doors = lab('doorsToggle');
  const autoH = lab('autoHideToggle');
  const ceil  = lab('hideCeilingToggle');
  const side  = document.getElementById('sidepanel');
  const animCard = document.getElementById('animCard');

  if(mode === 'clean'){
    if(doors) doors.style.display = 'none';
    if(autoH) autoH.style.display = 'none';
    if(ceil)  ceil.style.display  = 'none';
    side.style.display = 'none';
    removeShadowSystem();
    return;
  }
  const isAsset = (mode === 'asset');
  if(doors) doors.style.display = isAsset ? 'none' : '';
  if(autoH) autoH.style.display = isAsset ? 'none' : '';
  if(ceil)  ceil.style.display  = isAsset ? 'none' : '';

  side.style.display = isAsset ? '' : 'none';
  animCard.style.display = isAsset ? '' : 'none';
  if(!isAsset) removeShadowSystem();

  updateTopbarVar();
  placeVariantsForViewport();
}
setUIMode('clean');

/* ---------- helpers ---------- */
function setMsg(t){ document.getElementById('msg').textContent = t || ''; }
function disposeMat(m){ ['map','normalMap','roughnessMap','metalnessMap','occlusionMap','emissiveMap'].forEach(k=>m[k]?.dispose?.()); }
function clearModel(){
  if(!current) return;
  scene.remove(current);
  current.traverse?.(o=>{ if(o.geometry) o.geometry.dispose(); const m=o.material; if(m) (Array.isArray(m)?m:[m]).forEach(disposeMat); });
  current=null; allNodes=[]; doorPanels=[]; doorVariantPairs=[]; ceilings=[]; wallRoots=[]; lastHiddenWalls.clear();
  removeAssetUI(); removeDoorUI(); removeShadowSystem(); objectToGroup.clear(); objectToDoor.clear();
  lastGLBBytes = null;
  statModel.textContent = 'Model: —';
  statSize.textContent  = 'Size: —';
  statTris.textContent  = 'Tris: —';
  statBytes.textContent = 'GLB: —';
  statFile.textContent  = 'File: —';
  statVariant.textContent = 'Variant: —';
  mixer = null;

  // limpiar UI variantes
  variantSelect.innerHTML = '';
  swatchBar.innerHTML = '';
  variantsCard.style.display = 'none';
  variantsCard.dataset.hasVariants = '0';
}
function triCount(obj){ let t=0; obj.traverse(o=>{ if(o.isMesh){ const g=o.geometry; t += g?.index ? g.index.count/3 : (g?.attributes?.position?.count||0)/3; }}); return Math.round(t); }
function updateStats(sizeVec){
  const tris = current ? triCount(current).toLocaleString() : '—';
  const sz   = sizeVec ? `${sizeVec.x.toFixed(2)}×${sizeVec.y.toFixed(2)}×${sizeVec.z.toFixed(2)} m` : '—';
  statTris.textContent = `Tris: ${tris}`;
  statSize.textContent = `Size: ${sz}`;
}
function humanBytes(b){
  if(b==null) return '—';
  const u=['B','KB','MB','GB']; let i=0; let n=b;
  while(n>=1024 && i<u.length-1){ n/=1024; i++; }
  return `${n.toFixed(n<10&&i>0?1:0)} ${u[i]}`;
}
function cleanName(name){
  if(!name) return '';
  const base = name.split('/').pop();
  return base.replace(/^model_/i,'').replace(/\.(glb|gltf)$/i,'');
}
function niceLabel(s){
  if(!s) return '';
  const t = s.replace(/^swatch_/i,'').replace(/_/g,' ');
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function variantToSwatchUrl(variantName){
  // Mapea "Wood" -> /swatches/swatch_Wood.jpg (respetando tu convención)
  return `./swatches/swatch_${variantName}.jpg`;
}

/* ---------- puertas (rooms) — estático ---------- */
function findDoorPanels(nodes){
  const panels = nodes.filter(o => /(leftpanel|rightpanel)\d+$/i.test(o.name) && !/_open|_closed/i.test(o.name));
  return panels.map(o=>{
    const left = /leftpanel/i.test(o.name);
    o.userData.closedQ  = o.quaternion.clone();
    o.userData.sign     = left ? +1 : -1;
    o.userData.groupKey = (o.name||'').toLowerCase();
    o.userData.idx      = (o.name.match(/(\d+)(?!.*\d)/)||[])[1];
    o.userData.side     = left ? 'left' : 'right';
    return o;
  });
}
function findDoorVariantPairs(nodes){
  const map = new Map();
  nodes.forEach(o=>{
    const m = o.name.match(/_(open|closed)(leftpanel|rightpanel)(\d+)$/i);
    if(!m) return;
    const state = m[1].toLowerCase();
    const side  = m[2].toLowerCase();
    const idx   = m[3];
    const group = (o.name||'').toLowerCase();
    const key   = `${group}|${side}|${idx}`;
    if(!map.has(key)) map.set(key, { open:null, closed:null, group, side, idx });
    map.get(key)[state] = o;
  });
  return Array.from(map.values()).filter(p => p.open || p.closed);
}
function getDoorRootsByIndex(groupKeyPref, idx, sidePref){
  const roots = [];
  doorPanels.forEach(d=>{
    const di   = d.userData.idx;
    const side = d.userData.side;
    const gk   = d.userData.groupKey;
    if(String(di) === String(idx)
      && (!sidePref || sidePref===side)
      && (!groupKeyPref || groupKeyPref===gk)) roots.push(d);
  });
  doorVariantPairs.forEach(pair=>{
    const { open, closed, group, side, idx:pi } = pair;
    [open, closed].filter(Boolean).forEach(n=>{
      const di = pi;
      const gk = group;
      const sd = side;
      if(String(di) === String(idx)
        && (!sidePref || sidePref===sd)
        && (!groupKeyPref || groupKeyPref===gk)) roots.push(n);
    });
  });
  return roots;
}
function pickPreferredDoorRoot(idx, sidePref, groupKeyPref){
  const roots = getDoorRootsByIndex(groupKeyPref, idx, sidePref);
  if(!roots.length){
    const anyGroup = getDoorRootsByIndex(null, idx, sidePref);
    if(anyGroup.length) return anyGroup.find(r=>r.visible===true) || anyGroup[0];
    const anySideAnyGroup = getDoorRootsByIndex(null, idx, null);
    if(anySideAnyGroup.length) return anySideAnyGroup.find(r=>r.visible===true) || anySideAnyGroup[0];
    return null;
  }
  return roots.find(r=>r.visible===true) || roots[0];
}
function reparentHardwareToDoors(nodes, _doorPanels){
  const hardware = nodes.filter(o => /(handle|hinge|knob|hardware)/i.test(o.name));
  hardware.forEach(h=>{
    const idx   = (h.name.match(/(\d+)(?!.*\d)/)||[])[1];
    const sideM = /left/i.test(h.name) ? 'left' : (/right/i.test(h.name) ? 'right' : null);

    let target = (idx!=null) ? pickPreferredDoorRoot(idx, sideM, (h.name||'').toLowerCase()) : null;

    if(!target){
      let candidates = _doorPanels;
      const sameGroup = _doorPanels.filter(d => (d.userData.groupKey || '') === (h.name||'').toLowerCase());
      if(sameGroup.length) candidates = sameGroup;
      if(sideM){
        const filtered = candidates.filter(d=> (d.userData.side)===sideM);
        if(filtered.length) candidates = filtered;
      }
      let best=null, bestDist=Infinity;
      const hp = new THREE.Vector3(); new THREE.Box3().setFromObject(h).getCenter(hp);
      candidates.forEach(d=>{
        const dp = new THREE.Vector3(); new THREE.Box3().setFromObject(d).getCenter(dp);
        const dist = hp.distanceTo(dp);
        if(dist<bestDist){ bestDist=dist; best=d; }
      });
      target = best;
    }

    if(target && h.parent !== target){
      h.updateMatrixWorld(true);
      const childWorld = h.matrixWorld.clone();
      target.updateMatrixWorld(true);
      target.add(h);
      const invParentWorld = target.matrixWorld.clone().invert();
      const local = new THREE.Matrix4().multiplyMatrices(invParentWorld, childWorld);
      local.decompose(h.position, h.quaternion, h.scale);
      h.updateMatrixWorld(true);
    }
  });
}
function enforceDoorVariantExclusivity(defaultState='closed'){
  doorVariantPairs.forEach(({open, closed})=>{
    if(open && closed){
      open.visible   = (defaultState === 'open');
      closed.visible = (defaultState === 'closed');
    }else if(open){
      open.visible = (defaultState === 'open');
    }else if(closed){
      closed.visible = (defaultState === 'closed');
    }
  });
}

/* ---------- Asset UI (morphs) ---------- */
function removeAssetUI(){
  animGroups = [];
  const panel = document.getElementById('animPanel');
  if(panel) panel.innerHTML = '';
}
function collectMorphMeshes(root){
  const out = [];
  root.traverse(o=>{ if(o.isMesh && o.morphTargetInfluences && o.morphTargetDictionary){ out.push(o); }});
  return out;
}
function uniqueNamesFromMeshes(meshes){
  const set = new Set();
  meshes.forEach(m=>{ const d=m.morphTargetDictionary; if(!d) return; Object.keys(d).forEach(k=>set.add(k)); });
  return Array.from(set);
}
function findAnimRoots(asset){
  const arr=[]; asset.traverse(o=>{ if(o!==asset && o.name && /^anim_/i.test(o.name)) arr.push(o); });
  return arr;
}
function stripAnimPrefix(s){ return s?.replace(/^anim_/i,'') ?? s; }

/* ---------- Doors from clips ---------- */
function removeDoorUI(){ doorGroups = []; }
function buildDoorControlsFromClips(root, clips){
  if(!clips?.length) return;
  const panel = document.getElementById('animPanel');
  if(!panel) return;

  clips
    .filter(c => /^door_/i.test(c.name))
    .forEach((clip)=>{
      const track = clip.tracks[0];
      if(!track) return;

      if(!mixer) mixer = new THREE.AnimationMixer(root);
      const action = mixer.clipAction(clip);
      action.clampWhenFinished = true;
      action.enabled = true;
      action.play();
      action.paused = true;
      action.time   = 0;

      const pathFull = track.name.split('.')[0];
      const pathBase = pathFull.split('/').pop();

      let targetNode = null;
      root.traverse(o=>{ if(!targetNode && o.name === pathBase) targetNode = o; });
      if(!targetNode) targetNode = root;

      targetNode.traverse(n=> objectToDoor.set(n, doorGroups.length));

      doorGroups.push({
        name: (targetNode.name||'').replace(/^door_/i,''),
        clip, action, node: targetNode,
        duration: clip.duration, value: 0, slider: null
      });
    });

  renderActionsPanel();
}
function renderActionsPanel(){
  const panel = document.getElementById('animPanel');
  if(!panel) return;
  panel.innerHTML = '';

  // Puertas
  doorGroups.forEach((g)=>{
    const row = document.createElement('div'); row.className='act-row';
    const name = document.createElement('div'); name.textContent = g.name; row.appendChild(name);
    const slider = document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='1'; slider.step='0.01'; slider.value=String(g.value);
    slider.oninput = ()=> setDoorValue(g, parseFloat(slider.value));
    row.appendChild(slider); g.slider = slider;
    panel.appendChild(row);
  });

  // Morphs
  if(!assetRoot){
    document.getElementById('animCard').style.display='none';
    return;
  }
  const animRoots = findAnimRoots(assetRoot);
  const groups = [];
  objectToGroup.clear();

  animRoots.forEach((ar, gi)=>{
    const meshes = collectMorphMeshes(ar); if(!meshes.length) return;
    const morphNames = uniqueNamesFromMeshes(meshes); if(!morphNames.length) return;
    ar.traverse(n=>{ objectToGroup.set(n, gi); });
    groups.push({ name: ar.name, node: ar, meshes, morphNames, activeMorph: morphNames[0], sliderEl:null });
  });
  animGroups = groups;

  animGroups.forEach(group=>{
    const row = document.createElement('div'); row.className='act-row';
    const label = document.createElement('div'); label.textContent = stripAnimPrefix(group.name); row.appendChild(label);

    const slider = document.createElement('input'); slider.type='range'; slider.min='0'; slider.max='1'; slider.step='0.01'; slider.value='0';
    slider.oninput=()=>{ const val=parseFloat(slider.value);
      group.meshes.forEach(m=>{ const d=m.morphTargetDictionary, inf=m.morphTargetInfluences; if(!d||!inf) return;
        if(group.activeMorph in d){ inf[d[group.activeMorph]]=val; m.needsUpdate=true; }
      });
    };
    row.appendChild(slider); group.sliderEl=slider;
    panel.appendChild(row);
  });

  document.getElementById('animCard').style.display='';
}
function setDoorValue(group, value){
  group.value = THREE.MathUtils.clamp(value, 0, 1);
  if(!group.action) return;
  group.action.paused = true;
  group.action.time   = group.duration * group.value;
  group.action.syncWith(group.action);
  if(group.slider) group.slider.value = String(group.value);
}
function tweenDoor(group, toValue, durationMs=500){
  const from = group.value ?? 0;
  const start = performance.now();
  const step = (t)=>{
    const k = Math.min(1, (t-start)/durationMs);
    const v = from + (toValue-from)*k;
    setDoorValue(group, v);
    if(k<1) requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

/* ---------- Sombras suaves (shadow catcher) ---------- */
function setCastShadow(obj, val){ obj.traverse(o=>{ if(o.isMesh){ o.castShadow = !!val; }}); }
function ensureShadowSystem(){
  if(!assetRoot) return;

  if(!dirLight){
    dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048,2048);
    dirLight.shadow.bias = -0.00015;
    dirLight.shadow.normalBias = 0.015;
    scene.add(dirLight);
  }
  if(!shadowPlane){
    const mat = new THREE.ShadowMaterial({ opacity: 0.07 });
    const geo = new THREE.PlaneGeometry(1,1);
    shadowPlane = new THREE.Mesh(geo, mat);
    shadowPlane.rotation.x = -Math.PI/2;
    shadowPlane.receiveShadow = true;
    shadowPlane.renderOrder = -1;
    scene.add(shadowPlane);
  }

  const box = new THREE.Box3().setFromObject(assetRoot);
  const size= box.getSize(new THREE.Vector3());
  const ctr = box.getCenter(new THREE.Vector3());

  shadowPlane.position.set(ctr.x, box.min.y + 0.0001, ctr.z);
  shadowPlane.scale.set(size.x*1.05, size.z*1.05, 1);

  const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
  const elev = 0.9;
  const lateral = 0.25;
  dirLight.position.set(ctr.x + dir.x*size.x*lateral, box.max.y + size.y*1.4*elev, ctr.z + dir.z*size.z*lateral);
  dirLight.target.position.set(ctr.x, ctr.y, ctr.z);
  scene.add(dirLight.target);

  dirLight.shadow.radius = 4.0;

  const cam = dirLight.shadow.camera;
  const r = Math.max(size.x, size.z) * 0.65;
  cam.left=-r; cam.right=r; cam.top=r; cam.bottom=-r; cam.near=0.1; cam.far=size.y * 4.0;
  cam.updateProjectionMatrix();

  setCastShadow(assetRoot, true);
}
function removeShadowSystem(){
  if(shadowPlane){
    shadowPlane.geometry.dispose(); shadowPlane.material.dispose();
    scene.remove(shadowPlane); shadowPlane=null;
  }
  if(dirLight){
    scene.remove(dirLight.target);
    scene.remove(dirLight);
    dirLight = null;
  }
}

/* ---------- Variants (KHR_materials_variants) ---------- */
async function setupVariants(gltf){
  variantSelect.innerHTML = '';
  swatchBar.innerHTML = '';
  variantsCard.style.display = 'none';
  variantsCard.dataset.hasVariants = '0';
  statVariant.textContent = 'Variant: —';

  const parser = gltf.parser;
  const json   = parser.json;
  const rootExt = json.extensions && json.extensions.KHR_materials_variants;
  if(!rootExt || !rootExt.variants || !rootExt.variants.length){
    placeVariantsForViewport();
    return;
  }

  const variantNames = rootExt.variants.map(v => v.name);

  // cache materiales
  const matCache = new Map();
  const getMaterialByIndex = (i) => {
    if (!matCache.has(i)) matCache.set(i, parser.getDependency('material', i));
    return matCache.get(i);
  };

  // guardar material original
  gltf.scene.traverse(o => {
    if (o.isMesh && o.material && !o.userData._origMaterial) {
      o.userData._origMaterial = o.material;
    }
  });

  async function applyVariant(root, name){
    const nameToIdx = new Map(rootExt.variants.map((v, i) => [v.name, i]));
    const wantedIdx = nameToIdx.get(name);
    if (wantedIdx == null) return;

    const pending = [];
    root.traverse(obj => {
      if (!obj.isMesh) return;
      const ext = obj.userData?.gltfExtensions?.KHR_materials_variants;
      if (!ext || !ext.mappings) {
        if (obj.userData._origMaterial) obj.material = obj.userData._origMaterial;
        return;
      }
      let chosen = null;
      for (const m of ext.mappings) {
        if (m.variants?.includes(wantedIdx)) { chosen = m; break; }
      }
      if (chosen && typeof chosen.material === 'number') {
        pending.push(getMaterialByIndex(chosen.material).then(mat => { obj.material = mat; }));
      } else {
        if (obj.userData._origMaterial) obj.material = obj.userData._origMaterial;
      }
    });
    await Promise.all(pending);

    // UI: marcar selección
    Array.from(swatchBar.children).forEach(btn=>{
      btn.classList.toggle('selected', btn.dataset.variant === name);
    });
    statVariant.textContent = `Variant: ${niceLabel(name)}`;
  }

  // construir opciones (desktop)
  variantNames.forEach((n, i)=>{
    const opt = document.createElement('option');
    opt.value = n; opt.textContent = n;
    if (i===0) opt.selected = true;
    variantSelect.appendChild(opt);
  });

  // construir swatches (móvil)
  variantNames.forEach((n, i)=>{
    const url = variantToSwatchUrl(n);
    const s = document.createElement('div');
    s.className = 'swatch';
    s.dataset.variant = n;
    const inner = document.createElement('div');
    inner.className = 'swatch-inner';
    inner.style.backgroundImage = `url("${url}")`;
    s.appendChild(inner);
    s.onclick = ()=> { variantSelect.value = n; applyVariant(gltf.scene, n); };
    swatchBar.appendChild(s);
  });

  // mostrar card y ubicar según viewport
  variantsCard.dataset.hasVariants = '1';
  variantsCard.style.display = '';
  placeVariantsForViewport();

  // aplicar primera por defecto
  await applyVariant(gltf.scene, variantNames[0]);

  // desktop change
  variantSelect.onchange = async ()=> { await applyVariant(gltf.scene, variantSelect.value); };
}

/* ---------- placing ---------- */
let mixerCreated = false;
function place(root, clips){
  root.traverse(o=>{
    if(o.isMesh && /collider/i.test(o.name)) o.visible=false;
    if(o.isMesh && /^ceiling\d*$/i.test(o.name)) o.visible=false;
  });

  new THREE.Box3().setFromObject(root).getCenter(root.position).multiplyScalar(-1);
  const box  = new THREE.Box3().setFromObject(root);
  const size = box.getSize(new THREE.Vector3());
  root.position.y -= box.min.y;

  allNodes = []; root.traverse(o=>{ if(o.name) allNodes.push(o); });
  ceilings  = allNodes.filter(o => /^ceiling\d*$/i.test(o.name));
  wallRoots = allNodes.filter(o => /^wall\d+$/i.test(o.name));

  doorPanels       = findDoorPanels(allNodes);
  doorVariantPairs = findDoorVariantPairs(allNodes);
  enforceDoorVariantExclusivity('closed');
  reparentHardwareToDoors(allNodes, doorPanels);

  current = root; scene.add(root);

  assetRoot = null;
  current.traverse(o=>{ if(!assetRoot && o.name && /^model_/i.test(o.name)) assetRoot = o; });

  setUIMode(assetRoot ? 'asset' : 'room');
  removeDoorUI();
  if(assetRoot){
    buildDoorControlsFromClips(current, clips||[]);
    renderActionsPanel();
    ensureShadowSystem();
  } else {
    removeAssetUI(); removeShadowSystem(); objectToGroup.clear(); objectToDoor.clear();
  }

  if(!mixerCreated){ mixer = new THREE.AnimationMixer(current); mixerCreated = true; }

  const maxDim = Math.max(size.x,size.y,size.z);
  camera.position.setScalar(maxDim*1.6).setY(maxDim*0.8);
  controls.target.copy(new THREE.Box3().setFromObject(root).getCenter(new THREE.Vector3()));
  controls.update();

  statModel.textContent = `Model: ${cleanName(root.name || 'Scene')}`;
  updateStats(size);
  updateTopbarVar();
  placeVariantsForViewport();
}

/* ---------- auto-hide wall (rooms) ---------- */
const ray = new THREE.Raycaster();
function wallRootOf(obj){ let p=obj; while(p){ if(/^wall\d+$/i.test(p.name)) return p; p=p.parent; } return null; }
function sampleFrontWalls(){
  if(!wallRoots?.length) return new Set();
  let closest=null, closestDist=Infinity;
  const distToTarget = camera.position.distanceTo(controls.target);
  const samples=[{x:0,y:0},{x:0.14,y:0},{x:-0.14,y:0},{x:0,y:0.14},{x:0,y:-0.14}];
  for(const ndc of samples){
    ray.setFromCamera(ndc, camera);
    const hits = ray.intersectObjects(wallRoots, true);
    if(hits.length){
      const h = hits[0];
      if(h.distance < distToTarget*0.995 && h.distance < closestDist){
        closest = wallRootOf(h.object); closestDist = h.distance;
      }
    }
  }
  return closest ? new Set([closest]) : new Set();
}
function updateAutoHide(){
  const autoHToggle=document.getElementById('autoHideToggle');
  if(!autoHToggle || autoHToggle.closest('label').style.display==='none') return;
  if(!autoHToggle.checked || !current) return;
  const front = sampleFrontWalls();
  for(const wr of Array.from(lastHiddenWalls)){ if(!front.has(wr)){ wr.visible=true; lastHiddenWalls.delete(wr);} }
  for(const wr of front){ if(!lastHiddenWalls.has(wr)){ wr.visible=false; lastHiddenWalls.add(wr);} }
}

/* ---------- Clicks (morphs y puertas) ---------- */
const mouse = new THREE.Vector2();
let downPos = null;
function screenToNDC(e){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
}
function findMorphGroupFromObject(obj){
  let p=obj; while(p){ if(objectToGroup.has(p)) return objectToGroup.get(p); p=p.parent; } return null;
}
function findDoorGroupFromObject(obj){
  let p=obj; while(p){ if(objectToDoor.has(p)) return objectToDoor.get(p); p=p.parent; } return null;
}
canvas.addEventListener('pointerdown', (e)=>{ downPos = {x:e.clientX,y:e.clientY}; });
canvas.addEventListener('pointerup', (e)=>{
  if(controls.dragging) return;
  if(downPos && (Math.hypot(e.clientX-downPos.x, e.clientY-downPos.y) > 3)) return;

  const rect = renderer.domElement.getBoundingClientRect();
  if(e.clientY < rect.top + (topbar?.offsetHeight||0)) return;

  screenToNDC(e);
  ray.setFromCamera(mouse, camera);
  const intersects = ray.intersectObject(current ?? scene, true);
  if(!intersects.length) return;

  const obj = intersects[0].object;

  const dIdx = findDoorGroupFromObject(obj);
  if(dIdx!=null){
    const g = doorGroups[dIdx];
    const target = (g.value >= 0.5) ? 0 : 1;
    tweenDoor(g, target, 500);
    return;
  }
  if(assetRoot){
    const gi = findMorphGroupFromObject(obj);
    if(gi!=null){
      const group = animGroups[gi];
      const probe = group.meshes.find(m=>m.morphTargetDictionary && group.activeMorph in m.morphTargetDictionary);
      if(probe){
        const idx = probe.morphTargetDictionary[group.activeMorph];
        const cur = probe.morphTargetInfluences[idx] ?? 0;
        const target = (cur >= 0.5) ? 0 : 1;
        const start = performance.now();
        const from = cur;
        const step = (t)=>{
          const k = Math.min(1, (t-start)/500);
          const v = from + (target-from)*k;
          group.meshes.forEach(m=>{
            const d=m.morphTargetDictionary, inf=m.morphTargetInfluences; if(!d||!inf) return;
            if(group.activeMorph in d){ inf[d[group.activeMorph]] = v; m.needsUpdate = true; }
          });
          if(group.sliderEl) group.sliderEl.value = String(v);
          if(k<1) requestAnimationFrame(step);
        };
        requestAnimationFrame(step);
      }
    }
  }
});

/* ---------- loading ---------- */
function loadBlob(file){
  setUIMode('clean'); setMsg('Loading local file…'); clearModel();
  const pre = (file.name && /_(00|0[0-9])\.(glb|gltf)$/i.test(file.name.toLowerCase())) ? 'room' : null;
  if(pre) setUIMode(pre);
  lastGLBBytes = file.size; statBytes.textContent = `GLB: ${humanBytes(lastGLBBytes)}`;
  statFile.textContent = `File: ${cleanName(file.name)}`;
  const url = URL.createObjectURL(file);
  loader.load(url, async (g)=>{
      g.scene.name = g.scene.name || file.name;
      place(g.scene, g.animations||[]);
      await setupVariants(g);
      setMsg(cleanName(file.name));
      URL.revokeObjectURL(url);
    },
    undefined, e=>{ console.error(e); setMsg('Error with local file'); });
}

/* ---------- UI ---------- */
const fileInput = document.getElementById('fileInput');
document.getElementById('fileBtn').onclick = ()=>{ fileInput.value=''; fileInput.click(); };
fileInput.onchange = ()=>{ const f=fileInput.files?.[0]; if(f) loadBlob(f); };
document.getElementById('doorsToggle').onchange = e=> {/* room only */};
document.getElementById('hideCeilingToggle').onchange = e=>{ ceilings.forEach(c=> c.visible = !e.target.checked); };

/* ---------- drag & drop ---------- */
const drop=document.getElementById('drop');
['dragenter','dragover','dragleave','drop'].forEach(ev=>{
  window.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); }, false);
});
window.addEventListener('dragenter', ()=> drop.style.display='flex');
window.addEventListener('dragover',  ()=> drop.style.display='flex');
window.addEventListener('dragleave', e=>{
  if(e.clientX<=0||e.clientY<=0||e.clientX>=innerWidth||e.clientY>=innerHeight){ drop.style.display='none'; }
});
function handleDrop(e){
  e.preventDefault(); e.stopPropagation();
  drop.style.display='none';
  const f=e.dataTransfer?.files?.[0]; if(f) loadBlob(f);
}
drop.addEventListener('drop', handleDrop);

/* ---------- stats toggle (mobile) ---------- */
const statsEl = document.getElementById('stats');
const statsToggle = document.getElementById('statsToggle');
function isMobile(){ return window.matchMedia('(max-width: 640px)').matches; }
function applyStatsMode(){
  if(isMobile()){
    statsEl.classList.remove('open');
    statsToggle.style.display = 'inline-flex';
    statsToggle.setAttribute('aria-expanded','false');
  }else{
    statsEl.classList.add('open');
    statsToggle.style.display = 'none';
    statsToggle.setAttribute('aria-expanded','true');
  }
}
statsToggle.addEventListener('click', ()=>{ if(!isMobile()) return;
  const open = statsEl.classList.toggle('open');
  statsToggle.setAttribute('aria-expanded', open ? 'true':'false');
});
addEventListener('resize', ()=>{ applyStatsMode(); placeVariantsForViewport(); updateTopbarVar(); });
applyStatsMode();
placeVariantsForViewport();

/* ---------- resize & loop ---------- */
function resize(){
  const w=innerWidth,h=innerHeight;
  renderer.setSize(w,h,false);
  camera.aspect=w/h; camera.updateProjectionMatrix();
  updateTopbarVar();
}
addEventListener('resize', ()=>{ resize(); ensureShadowSystem(); });
resize();

/* ---------- perf update & render loop ---------- */
let lastT = performance.now();
renderer.setAnimationLoop(()=>{
  const now = performance.now();
  const dt = now - lastT; lastT = now;
  const fpsInst = 1000/dt;
  fpsEMA = fpsEMA ? (fpsEMA*0.9 + fpsInst*0.1) : fpsInst;

  const info = renderer.info;
  statFPS.textContent   = `FPS: ${fpsEMA.toFixed(0)}`;
  statMS.textContent    = `ms: ${dt.toFixed(1)}`;
  statCalls.textContent = `Calls: ${info.render.calls}`;
  statGeoms.textContent = `Geoms: ${info.memory.geometries}`;
  statText.textContent  = `Tex: ${info.memory.textures}`;

  if(mixer) mixer.update(dt/1000);

  controls.update();
  updateAutoHide();
  ensureShadowSystem();
  renderer.render(scene,camera);
});
</script>
</body>
</html>
